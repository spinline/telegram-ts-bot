<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/backend/.env">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/.env" />
              <option name="originalContent" value="API_BASE_URL=https://remnawave.karatatar.com&#10;API_TOKEN=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1dWlkIjoiZDhjMDRhYTItYWMzNS00MGZmLThjMjUtNjkwYzMzYzEyYTBjIiwidXNlcm5hbWUiOm51bGwsInJvbGUiOiJBUEkiLCJpYXQiOjE3NjM0MDIwNzEsImV4cCI6MTA0MDMzMTU2NzF9.xs_UJcn1Wd9A9r8NHIu_yK5JOHcTGanmzYqa8BwPsac&#10;BOT_TOKEN=8410224035:AAGQOwltivgf3MFNGdsaAxVsFcfbzjtIq1s&#10;MINI_APP_URL=https://telegram-mini-app-frontend.karatatar.com&#10;INTERNAL_SQUAD_UUID=b9bbdfd4-e63b-4ba7-8a72-d036710d17d8&#10;WEBHOOK_SECRET=9807bd3a6533bc3c72d9d67a904427811e433415de1300b8b76d80e07a8aa476a08bf2c30bc7252eb810b81fb8281de2d149b41350fbc2a17c9cc015c489498f&#10;" />
              <option name="updatedContent" value="API_BASE_URL=https://remnawave.karatatar.com&#10;API_TOKEN=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1dWlkIjoiZDhjMDRhYTItYWMzNS00MGZmLThjMjUtNjkwYzMzYzEyYTBjIiwidXNlcm5hbWUiOm51bGwsInJvbGUiOiJBUEkiLCJpYXQiOjE3NjM0MDIwNzEsImV4cCI6MTA0MDMzMTU2NzF9.xs_UJcn1Wd9A9r8NHIu_yK5JOHcTGanmzYqa8BwPsac&#10;BOT_TOKEN=8410224035:AAGQOwltivgf3MFNGdsaAxVsFcfbzjtIq1s&#10;MINI_APP_URL=https://telegram-mini-app-frontend.karatatar.com&#10;INTERNAL_SQUAD_UUID=b9bbdfd4-e63b-4ba7-8a72-d036710d17d8&#10;PORT=3000&#10;PUBLIC_BASE_URL=https://telegram-ts-bot-backend.karatatar.com&#10;WEBHOOK_SECRET=9807bd3a6533bc3c72d9d67a904427811e433415de1300b8b76d80e07a8aa476a08bf2c30bc7252eb810b81fb8281de2d149b41350fbc2a17c9cc015c489498f&#10;INTERNAL_NOTIFY_TOKEN=test_secret_token_2024&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/.env.production">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/.env.production" />
              <option name="originalContent" value="# Production Environment Variables&#10;# Bu değerleri Dokploy dashboard'dan override edebilirsiniz&#10;&#10;API_BASE_URL=https://remnawave.karatatar.com&#10;API_TOKEN=YOUR_API_TOKEN_HERE&#10;BOT_TOKEN=YOUR_BOT_TOKEN_HERE&#10;MINI_APP_URL=https://telegram-mini-app-frontend.karatatar.com&#10;INTERNAL_SQUAD_UUID=YOUR_SQUAD_UUID_HERE&#10;PORT=3000&#10;PUBLIC_BASE_URL=https://telegram-ts-bot-backend.karatatar.com&#10;&#10;# Webhook ayarları (Gerçek zamanlı bildirimler)&#10;WEBHOOK_SECRET=9807bd3a6533bc3c72d9d67a904427811e433415de1300b8b76d80e07a8aa476a08bf2c30bc7252eb810b81fb8281de2d149b41350fbc2a17c9cc015c489498f&#10;#&#10;# ╔════════════════════════════════════════════════════════════════════════════╗&#10;# ║ RemnaWave Panelinde Webhook Ayarları:                                      ║&#10;# ╠════════════════════════════════════════════════════════════════════════════╣&#10;# ║ URL:    https://telegram-ts-bot-backend.karatatar.com/endpoint            ║&#10;# ║ Secret: 9807bd3a6533bc3c72d9d67a904427811e433415de1300b8b76d80e0...      ║&#10;# ║                                                                            ║&#10;# ║ NOT: RemnaWave tüm eventleri gönderecek, backend otomatik filtreleyecek   ║&#10;# ║      (user.limited, user.expired, user.disabled, user.status.changed)     ║&#10;# ╚════════════════════════════════════════════════════════════════════════════╝&#10;#&#10;# Bu URL'e RemnaWave paneli kullanıcı durumu değiştiğinde POST isteği gönderecek&#10;&#10;# Internal test endpoint için güvenlik token'ı&#10;INTERNAL_NOTIFY_TOKEN=YOUR_SECRET_TOKEN_HERE&#10;# Test kullanımı: curl -X POST &quot;http://localhost:3000/internal/test-webhook/123456789&quot; \&#10;#   -H &quot;x-internal-token: YOUR_SECRET_TOKEN_HERE&quot; \&#10;#   -H &quot;Content-Type: application/json&quot; \&#10;#   -d '{&quot;reason&quot;:&quot;Test bildirimi&quot;}'&#10;&#10;&#10;" />
              <option name="updatedContent" value="# Production Environment Variables&#10;# ⚠️ DİKKAT: Bu dosya GİT'E ASLA COMMIT EDİLMEMELİ!&#10;&#10;API_BASE_URL=https://remnawave.karatatar.com&#10;API_TOKEN=YOUR_API_TOKEN_HERE&#10;BOT_TOKEN=YOUR_BOT_TOKEN_HERE&#10;MINI_APP_URL=https://telegram-mini-app-frontend.karatatar.com&#10;INTERNAL_SQUAD_UUID=YOUR_SQUAD_UUID_HERE&#10;PORT=3000&#10;PUBLIC_BASE_URL=https://telegram-ts-bot-backend.karatatar.com&#10;&#10;# Webhook ayarları - YENİ GÜVENLI SECRET (2024-11-21)&#10;WEBHOOK_SECRET=e38068b41c6a516abb9048c469a3a94d11bf4c02ee525858d8da3868131b509377db870e607b2ef52589a1fefd451c0e658311a48a7e0662a0517f4c3796b8f7&#10;#&#10;# ╔════════════════════════════════════════════════════════════════════════════╗&#10;# ║ RemnaWave Panelinde Webhook Ayarları:                                      ║&#10;# ╠════════════════════════════════════════════════════════════════════════════╣&#10;# ║ URL:    https://telegram-ts-bot-backend.karatatar.com/endpoint            ║&#10;# ║ Secret: e38068b41c6a516abb9048c469a3a94d11bf4c02ee525858d8da...          ║&#10;# ║                                                                            ║&#10;# ║ NOT: RemnaWave tüm eventleri gönderecek, backend otomatik filtreleyecek   ║&#10;# ║      (user.limited, user.expired, user.disabled, user.status.changed)     ║&#10;# ╚════════════════════════════════════════════════════════════════════════════╝&#10;&#10;# Internal test endpoint için güvenlik token'ı - YENİ (2024-11-21)&#10;INTERNAL_NOTIFY_TOKEN=54112d9f74ff1372f2cc4b91b295ad8678411effb497c889836697838d0b30a6&#10;&#10;&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/.env.production.example">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/.env.production.example" />
              <option name="updatedContent" value="# Production Environment Variables - TEMPLATE&#10;# ÖNEMLİ: Bu dosyayı .env.production olarak kopyalayın ve gerçek değerlerle doldurun&#10;&#10;API_BASE_URL=https://remnawave.karatatar.com&#10;API_TOKEN=YOUR_API_TOKEN_HERE&#10;BOT_TOKEN=YOUR_BOT_TOKEN_HERE&#10;MINI_APP_URL=https://telegram-mini-app-frontend.karatatar.com&#10;INTERNAL_SQUAD_UUID=YOUR_SQUAD_UUID_HERE&#10;PORT=3000&#10;PUBLIC_BASE_URL=https://telegram-ts-bot-backend.karatatar.com&#10;&#10;# Webhook ayarları (Gerçek zamanlı bildirimler)&#10;# Webhook secret oluşturmak için: openssl rand -hex 64&#10;WEBHOOK_SECRET=YOUR_GENERATED_WEBHOOK_SECRET_HERE&#10;#&#10;# ╔════════════════════════════════════════════════════════════════════════════╗&#10;# ║ RemnaWave Panelinde Webhook Ayarları:                                      ║&#10;# ╠════════════════════════════════════════════════════════════════════════════╣&#10;# ║ URL:    https://telegram-ts-bot-backend.karatatar.com/endpoint            ║&#10;# ║ Secret: [WEBHOOK_SECRET değerini buraya girin]                            ║&#10;# ║                                                                            ║&#10;# ║ NOT: RemnaWave tüm eventleri gönderecek, backend otomatik filtreleyecek   ║&#10;# ║      (user.limited, user.expired, user.disabled, user.status.changed)     ║&#10;# ╚════════════════════════════════════════════════════════════════════════════╝&#10;#&#10;# Bu URL'e RemnaWave paneli kullanıcı durumu değiştiğinde POST isteği gönderecek&#10;&#10;# Internal test endpoint için güvenlik token'ı&#10;# Test secret oluşturmak için: openssl rand -hex 32&#10;INTERNAL_NOTIFY_TOKEN=YOUR_SECRET_TOKEN_HERE&#10;# Test kullanımı: curl -X POST &quot;http://localhost:3000/internal/test-webhook/123456789&quot; \&#10;#   -H &quot;x-internal-token: YOUR_SECRET_TOKEN_HERE&quot; \&#10;#   -H &quot;Content-Type: application/json&quot; \&#10;#   -d '{&quot;reason&quot;:&quot;Test bildirimi&quot;}'&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/NOTIFIER_README.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/NOTIFIER_README.md" />
              <option name="originalContent" value="# Otomatik Hesap Kısıtlama Bildirimi Sistemi&#10;&#10;## Genel Bakış&#10;&#10;Bu sistem, kullanıcı hesapları kısıtlandığında (trafik aşımı, abonelik bitişi, vb.) otomatik olarak Telegram üzerinden bildirim gönderir.&#10;&#10;##  İki Yöntem&#10;&#10;### 1️⃣ Webhook (ÖNERİLEN) ⚡&#10;&#10;**Gerçek zamanlı bildirimler** - RemnaWave paneli kullanıcı durumu değiştiğinde hemen webhook gönderir.&#10;&#10;✅ Anında bildirim (&lt;2 saniye)  &#10;✅ Düşük kaynak kullanımı  &#10;✅ API kontrolüne gerek yok  &#10;✅ Güvenli (HMAC imza doğrulama)&#10;&#10; **Detaylı kurulum:** [WEBHOOK_GUIDE.md](./WEBHOOK_GUIDE.md)&#10;&#10;**Hızlı Kurulum:**&#10;```bash&#10;# 1. Webhook secret oluştur&#10;WEBHOOK_SECRET=your_secret_here&#10;&#10;# 2. Notifier'ı kapat&#10;NOTIFY_INTERVAL_MS=0&#10;&#10;# 3. RemnaWave panelinde webhook URL'i ayarla&#10;# URL: https://your-domain.com/webhook/remnawave&#10;```&#10;&#10;### 2️⃣ Notifier (YEDEK) &#10;&#10;**Periyodik API kontrolü** - Belirli aralıklarla tüm kullanıcıları kontrol eder.&#10;&#10;⚠️ Yavaş (5 dakika gecikme)  &#10;⚠️ Yüksek kaynak kullanımı  &#10;⚠️ Sürekli API istekleri  &#10;&#10;**Ne Zaman Kullanılır:** Webhook kurulumu mümkün değilse.&#10;&#10;```bash&#10;NOTIFY_INTERVAL_MS=300000  # 5 dakika&#10;```&#10;&#10;## Özellikler&#10;&#10;### ✅ Otomatik Bildirim&#10;- Kullanıcının hesabı `LIMITED`, `EXPIRED` veya `DISABLED` durumuna geçtiğinde otomatik bildirim gönderilir&#10;- **Her kullanıcıya sadece BİR KEZ bildirim gönderilir** (tekrar gönderilmez)&#10;- Bildirimler kullanıcının Telegram chatId'sine gönderilir&#10;&#10;###  Periyodik Kontrol&#10;- Sistem belirlenen aralıklarla API'yi kontrol eder (default: 5 dakika)&#10;- Sayfalama ile tüm kullanıcıları tarar&#10;- Kısıtlanmış kullanıcıları otomatik tespit eder&#10;&#10;###  Test Endpoint'i&#10;- Manuel test için korumalı endpoint: `POST /internal/notify/user/:telegramId`&#10;- Güvenlik token ile korunur (`INTERNAL_NOTIFY_TOKEN`)&#10;&#10;## Ortam Değişkenleri&#10;&#10;### Zorunlu Değişkenler&#10;```bash&#10;API_BASE_URL=https://remnawave.karatatar.com&#10;API_TOKEN=your_api_token&#10;BOT_TOKEN=your_telegram_bot_token&#10;INTERNAL_NOTIFY_TOKEN=your_secret_token  # Test endpoint için&#10;```&#10;&#10;### İsteğe Bağlı Değişkenler&#10;```bash&#10;# Kontrol aralığı (milisaniye)&#10;NOTIFY_INTERVAL_MS=300000  # 5 dakika&#10;&#10;# Sayfa boyutu&#10;NOTIFY_PAGE_SIZE=200&#10;```&#10;&#10;## Bildirim Mantığı&#10;&#10;### Bildirim Koşulları&#10;Aşağıdaki durumlarda bildirim gönderilir:&#10;- `status === 'LIMITED'` → &quot;Trafik kotanız doldu.&quot;&#10;- `status === 'EXPIRED'` → &quot;Abonelik süreniz sona erdi.&quot;&#10;- `status === 'DISABLED'` → &quot;Hesabınız devre dışı bırakıldı.&quot;&#10;&#10;### Tekrar Gönderim Engelleme&#10;- Her kullanıcı için bildirim durumu bellekte tutulur (`notifiedUsers`)&#10;- Bir kez bildirim gönderilen kullanıcıya tekrar mesaj gönderilmez&#10;- Process restart olduğunda bellek temizlenir ve yeniden bildirim gönderilebilir&#10;&#10;### Bildirim Mesajı&#10;```&#10;⚠️ Hesabınız kısıtlandı!&#10;&#10;[Sebep: trafik/abonelik/devre dışı]&#10;&#10;Hesap detaylarınızı görmek için aşağıdaki butona tıklayın.&#10;&#10;[ Hesap Bilgilerim]&#10;```&#10;&#10;## Manuel Test&#10;&#10;### Test Endpoint Kullanımı&#10;&#10;```bash&#10;# Kullanıcı ID'si ile test&#10;curl -X POST &quot;http://localhost:3000/internal/notify/user/123456789&quot; \&#10;  -H &quot;x-internal-token: YOUR_SECRET_TOKEN_HERE&quot; \&#10;  -H &quot;Content-Type: application/json&quot; \&#10;  -d '{&quot;reason&quot;:&quot;Test bildirimi: hesabınız test için kısıtlandı&quot;}'&#10;```&#10;&#10;### Başarılı Yanıt&#10;```json&#10;{&#10;  &quot;ok&quot;: true&#10;}&#10;```&#10;&#10;### Hata Yanıtları&#10;```json&#10;// Kullanıcı bulunamadı&#10;{&#10;  &quot;error&quot;: &quot;User not found&quot;&#10;}&#10;&#10;// Daha önce bildirim gönderilmiş&#10;{&#10;  &quot;ok&quot;: false,&#10;  &quot;reason&quot;: &quot;already_notified&quot;&#10;}&#10;&#10;// Telegram ID yok&#10;{&#10;  &quot;ok&quot;: false,&#10;  &quot;error&quot;: &quot;No telegramId found on user object&quot;&#10;}&#10;```&#10;&#10;## Dosya Yapısı&#10;&#10;```&#10;backend/&#10;├── src/&#10;│   ├── index.ts           # Ana uygulama, bot ve endpoint'ler&#10;│   ├── notify.ts          # Bildirim sistemi&#10;│   └── api.ts             # API client fonksiyonları&#10;├── .env.production        # Ortam değişkenleri&#10;└── NOTIFIER_README.md     # Bu dosya&#10;```&#10;&#10;## Güvenlik Notları&#10;&#10;⚠️ **ÖNEMLİ**&#10;- `INTERNAL_NOTIFY_TOKEN` değerini güçlü bir rastgele string yapın&#10;- Test endpoint'ini production'da dikkatli kullanın&#10;- Kullanıcı botu engellerse Telegram hatası döner (bu normaldir ve loglanır)&#10;&#10;## Limitasyonlar&#10;&#10;1. **Bellek Tabanlı**: `notifiedUsers` process restart ile sıfırlanır&#10;2. **Telegram Limitleri**: Telegram API rate limit'lerine dikkat edin&#10;3. **Periyodik Kontrol**: Gerçek zamanlı değil, belirlenen aralıklarla çalışır&#10;&#10;## Gelecek İyileştirmeler&#10;&#10;- [ ] Redis/DB ile kalıcı bildirim geçmişi&#10;- [ ] Webhook entegrasyonu (gerçek zamanlı)&#10;- [ ] Bildirim şablonları (farklı mesaj türleri)&#10;- [ ] Metrik ve monitoring&#10;- [ ] E-posta bildirimi desteği&#10;&#10;## Sorun Giderme&#10;&#10;### Bildirim Gönderilmiyor&#10;1. `NOTIFY_INTERVAL_MS` değerini kontrol edin (0 ise sistem çalışmaz)&#10;2. API bağlantısını kontrol edin (`API_BASE_URL` ve `API_TOKEN`)&#10;3. Kullanıcının `telegramId` alanının dolu olduğundan emin olun&#10;4. Bot loglarını kontrol edin&#10;&#10;### &quot;already_notified&quot; Hatası&#10;- Bu kullanıcıya daha önce bildirim gönderilmiş&#10;- Process restart yapın veya test için farklı bir kullanıcı kullanın&#10;&#10;### Telegram Hatası&#10;- Kullanıcı botu engellemiş olabilir&#10;- Bot token'ını kontrol edin&#10;- Telegram API durumunu kontrol edin&#10;&#10;## Loglar&#10;&#10;Sistem aşağıdaki durumları loglar:&#10;```&#10;✅ Notifier started.&#10;✅ Bot started!&#10;⚠️  Failed sending notify to [telegramId]: [error]&#10;❌ Notifier error: [error]&#10;```&#10;&#10;" />
              <option name="updatedContent" value="# Otomatik Hesap Kısıtlama Bildirimi Sistemi&#10;&#10;## Genel Bakış&#10;&#10;Bu sistem, kullanıcı hesapları kısıtlandığında (trafik aşımı, abonelik bitişi, vb.) otomatik olarak Telegram üzerinden bildirim gönderir.&#10;&#10;##  İki Yöntem&#10;&#10;### 1️⃣ Webhook (ÖNERİLEN) ⚡&#10;&#10;**Gerçek zamanlı bildirimler** - RemnaWave paneli kullanıcı durumu değiştiğinde hemen webhook gönderir.&#10;&#10;✅ Anında bildirim (&lt;2 saniye)  &#10;✅ Düşük kaynak kullanımı  &#10;✅ API kontrolüne gerek yok  &#10;✅ Güvenli (HMAC imza doğrulama)&#10;&#10; **Detaylı kurulum:** [WEBHOOK_GUIDE.md](./WEBHOOK_GUIDE.md)&#10;&#10;**Hızlı Kurulum:**&#10;```bash&#10;# 1. Webhook secret oluştur&#10;WEBHOOK_SECRET=your_secret_here&#10;&#10;# 2. Notifier'ı kapat&#10;NOTIFY_INTERVAL_MS=0&#10;&#10;# 3. RemnaWave panelinde webhook URL'i ayarla&#10;# URL: https://your-domain.com/webhook/remnawave&#10;```&#10;&#10;### 2️⃣ Notifier (YEDEK) &#10;&#10;**Periyodik API kontrolü** - Belirli aralıklarla tüm kullanıcıları kontrol eder.&#10;&#10;⚠️ Yavaş (5 dakika gecikme)  &#10;⚠️ Yüksek kaynak kullanımı  &#10;⚠️ Sürekli API istekleri  &#10;&#10;**Ne Zaman Kullanılır:** Webhook kurulumu mümkün değilse.&#10;&#10;```bash&#10;NOTIFY_INTERVAL_MS=300000  # 5 dakika&#10;```&#10;&#10;## Özellikler&#10;&#10;### ✅ Otomatik Bildirim&#10;- Kullanıcının hesabı `LIMITED`, `EXPIRED` veya `DISABLED` durumuna geçtiğinde otomatik bildirim gönderilir&#10;- **Her kullanıcıya sadece BİR KEZ bildirim gönderilir** (tekrar gönderilmez)&#10;- Bildirimler kullanıcının Telegram chatId'sine gönderilir&#10;&#10;###  Periyodik Kontrol&#10;- Sistem belirlenen aralıklarla API'yi kontrol eder (default: 5 dakika)&#10;- Sayfalama ile tüm kullanıcıları tarar&#10;- Kısıtlanmış kullanıcıları otomatik tespit eder&#10;&#10;###  Test Endpoint'i&#10;- Manuel test için korumalı endpoint: `POST /internal/notify/user/:telegramId`&#10;- Güvenlik token ile korunur (`INTERNAL_NOTIFY_TOKEN`)&#10;&#10;## Ortam Değişkenleri&#10;&#10;### Zorunlu Değişkenler&#10;```bash&#10;API_BASE_URL=https://remnawave.karatatar.com&#10;API_TOKEN=your_api_token&#10;BOT_TOKEN=your_telegram_bot_token&#10;INTERNAL_NOTIFY_TOKEN=your_secret_token  # Test endpoint için&#10;```&#10;&#10;### Webhook Kullanıyorsanız (ÖNERİLEN)&#10;```bash&#10;WEBHOOK_SECRET=your_webhook_secret  # RemnaWave panelinde ayarlanan secret&#10;NOTIFY_INTERVAL_MS=0  # Notifier'ı kapat&#10;```&#10;&#10;### Notifier Kullanıyorsanız (YEDEK)&#10;```bash&#10;NOTIFY_INTERVAL_MS=300000  # 5 dakika&#10;NOTIFY_PAGE_SIZE=200&#10;```&#10;&#10;## Bildirim Mantığı&#10;&#10;### Bildirim Koşulları&#10;Aşağıdaki durumlarda bildirim gönderilir:&#10;- `status === 'LIMITED'` → &quot;Trafik kotanız doldu.&quot;&#10;- `status === 'EXPIRED'` → &quot;Abonelik süreniz sona erdi.&quot;&#10;- `status === 'DISABLED'` → &quot;Hesabınız devre dışı bırakıldı.&quot;&#10;&#10;### Tekrar Gönderim Engelleme&#10;- Her kullanıcı için bildirim durumu bellekte tutulur (`notifiedUsers`)&#10;- Bir kez bildirim gönderilen kullanıcıya tekrar mesaj gönderilmez&#10;- Process restart olduğunda bellek temizlenir ve yeniden bildirim gönderilebilir&#10;&#10;### Bildirim Mesajı&#10;```&#10;⚠️ Hesabınız kısıtlandı!&#10;&#10;[Sebep: trafik/abonelik/devre dışı]&#10;&#10;Hesap detaylarınızı görmek için aşağıdaki butona tıklayın.&#10;&#10;[ Hesap Bilgilerim]&#10;```&#10;&#10;## Manuel Test&#10;&#10;### Test Endpoint Kullanımı&#10;&#10;```bash&#10;# Kullanıcı ID'si ile test&#10;curl -X POST &quot;http://localhost:3000/internal/notify/user/123456789&quot; \&#10;  -H &quot;x-internal-token: YOUR_SECRET_TOKEN_HERE&quot; \&#10;  -H &quot;Content-Type: application/json&quot; \&#10;  -d '{&quot;reason&quot;:&quot;Test bildirimi: hesabınız test için kısıtlandı&quot;}'&#10;```&#10;&#10;### Başarılı Yanıt&#10;```json&#10;{&#10;  &quot;ok&quot;: true&#10;}&#10;```&#10;&#10;### Hata Yanıtları&#10;```json&#10;// Kullanıcı bulunamadı&#10;{&#10;  &quot;error&quot;: &quot;User not found&quot;&#10;}&#10;&#10;// Daha önce bildirim gönderilmiş&#10;{&#10;  &quot;ok&quot;: false,&#10;  &quot;reason&quot;: &quot;already_notified&quot;&#10;}&#10;&#10;// Telegram ID yok&#10;{&#10;  &quot;ok&quot;: false,&#10;  &quot;error&quot;: &quot;No telegramId found on user object&quot;&#10;}&#10;```&#10;&#10;## Dosya Yapısı&#10;&#10;```&#10;backend/&#10;├── src/&#10;│   ├── index.ts           # Ana uygulama, bot ve endpoint'ler&#10;│   ├── webhook.ts         # Webhook handler (gerçek zamanlı)&#10;│   ├── notify.ts          # Notifier (periyodik kontrol)&#10;│   └── api.ts             # API client fonksiyonları&#10;├── .env.production        # Ortam değişkenleri&#10;├── WEBHOOK_GUIDE.md       # Webhook kurulum rehberi (ÖNERİLEN)&#10;└── NOTIFIER_README.md     # Bu dosya&#10;```&#10;&#10;## Güvenlik Notları&#10;&#10;⚠️ **ÖNEMLİ**&#10;- `INTERNAL_NOTIFY_TOKEN` değerini güçlü bir rastgele string yapın&#10;- Test endpoint'ini production'da dikkatli kullanın&#10;- Kullanıcı botu engellerse Telegram hatası döner (bu normaldir ve loglanır)&#10;&#10;## Limitasyonlar&#10;&#10;1. **Bellek Tabanlı**: `notifiedUsers` process restart ile sıfırlanır&#10;2. **Telegram Limitleri**: Telegram API rate limit'lerine dikkat edin&#10;3. **Periyodik Kontrol**: Gerçek zamanlı değil, belirlenen aralıklarla çalışır&#10;&#10;## Gelecek İyileştirmeler&#10;&#10;- [ ] Redis/DB ile kalıcı bildirim geçmişi&#10;- [ ] Webhook entegrasyonu (gerçek zamanlı)&#10;- [ ] Bildirim şablonları (farklı mesaj türleri)&#10;- [ ] Metrik ve monitoring&#10;- [ ] E-posta bildirimi desteği&#10;&#10;## Sorun Giderme&#10;&#10;### Bildirim Gönderilmiyor&#10;1. `NOTIFY_INTERVAL_MS` değerini kontrol edin (0 ise sistem çalışmaz)&#10;2. API bağlantısını kontrol edin (`API_BASE_URL` ve `API_TOKEN`)&#10;3. Kullanıcının `telegramId` alanının dolu olduğundan emin olun&#10;4. Bot loglarını kontrol edin&#10;&#10;### &quot;already_notified&quot; Hatası&#10;- Bu kullanıcıya daha önce bildirim gönderilmiş&#10;- Process restart yapın veya test için farklı bir kullanıcı kullanın&#10;&#10;### Telegram Hatası&#10;- Kullanıcı botu engellemiş olabilir&#10;- Bot token'ını kontrol edin&#10;- Telegram API durumunu kontrol edin&#10;&#10;## Loglar&#10;&#10;Sistem aşağıdaki durumları loglar:&#10;```&#10;✅ Notifier started.&#10;✅ Bot started!&#10;⚠️  Failed sending notify to [telegramId]: [error]&#10;❌ Notifier error: [error]&#10;```&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/QUICKSTART.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/QUICKSTART.md" />
              <option name="originalContent" value="# Hızlı Başlangıç - Webhook Bildirim Sistemi&#10;&#10;## ✅ Tamamlandı&#10;&#10;Webhook entegrasyonu başarıyla eklendi! RemnaWave paneli kullanıcı durumu değiştiğinde otomatik olarak Telegram bildirimi gönderilecek.&#10;&#10;##  Dosyalar&#10;&#10;- ✅ `backend/src/webhook.ts` - Webhook handler&#10;- ✅ `backend/src/index.ts` - Webhook endpoint: `POST /webhook/remnawave`&#10;- ✅ `backend/WEBHOOK_GUIDE.md` - Detaylı webhook kurulum rehberi&#10;- ✅ `backend/.env.production` - Ortam değişkenleri&#10;&#10;##  Kurulum Adımları&#10;&#10;### 1. Webhook Secret Oluşturun&#10;&#10;```bash&#10;# Güçlü bir secret oluşturun&#10;openssl rand -hex 32&#10;```&#10;&#10;### 2. Environment Değişkenlerini Ayarlayın&#10;&#10;`.env.production` dosyasına ekleyin:&#10;&#10;```bash&#10;# Webhook (Gerçek zamanlı bildirimler)&#10;WEBHOOK_SECRET=your_generated_secret_here&#10;&#10;&#10;# Diğer zorunlu değişkenler&#10;API_BASE_URL=https://remnawave.karatatar.com&#10;API_TOKEN=your_api_token&#10;BOT_TOKEN=your_telegram_bot_token&#10;INTERNAL_NOTIFY_TOKEN=your_test_token&#10;```&#10;&#10;### 3. RemnaWave Panelinde Webhook Ayarlayın&#10;&#10;**Adım 1:** RemnaWave panel → Settings → Webhooks&#10;&#10;**Adım 2:** Yeni webhook ekleyin:&#10;- **URL:** `https://telegram-ts-bot-backend.karatatar.com/endpoint`&#10;- **Secret:** Yukarıda oluşturduğunuz secret&#10;- **Events:** &#10;  - ✅ user.status.changed&#10;  - ✅ user.limited&#10;  - ✅ user.expired&#10;  - ✅ user.disabled&#10;&#10;**Adım 3:** Kaydet ve test edin&#10;&#10;### 4. Backend'i Deploy Edin&#10;&#10;```bash&#10;cd backend&#10;npm install&#10;npm run build&#10;npm start&#10;&#10;# Veya docker ile&#10;docker build -t telegram-bot .&#10;docker run -p 3000:3000 telegram-bot&#10;```&#10;&#10;### 5. Test Edin&#10;&#10;```bash&#10;# Health check&#10;curl https://your-domain.com/health&#10;&#10;# Manuel webhook testi&#10;curl -X POST &quot;https://your-domain.com/webhook/remnawave&quot; \&#10;  -H &quot;Content-Type: application/json&quot; \&#10;  -d '{&#10;    &quot;event&quot;: &quot;user.limited&quot;,&#10;    &quot;timestamp&quot;: &quot;2024-11-21T10:30:00Z&quot;,&#10;    &quot;data&quot;: {&#10;      &quot;user&quot;: {&#10;        &quot;uuid&quot;: &quot;test-uuid&quot;,&#10;        &quot;username&quot;: &quot;test_user&quot;,&#10;        &quot;status&quot;: &quot;LIMITED&quot;,&#10;        &quot;telegramId&quot;: YOUR_TELEGRAM_ID&#10;      }&#10;    }&#10;  }'&#10;```&#10;&#10;##  Nasıl Çalışır?&#10;&#10;```&#10;Kullanıcı trafik limitini aşar (örn: 2GB)&#10;    ↓&#10;RemnaWave paneli status değiştirir: ACTIVE → LIMITED&#10;    ↓&#10;Panel webhook gönderir: POST https://your-domain.com/webhook/remnawave&#10;    ↓&#10;Backend webhook'u alır ve imzayı doğrular (HMAC SHA256)&#10;    ↓&#10;Kullanıcının telegramId'si kontrol edilir&#10;    ↓&#10;Telegram bildirimi gönderilir (&lt;1 saniye)&#10;    ↓&#10;Kullanıcı işaretlenir (bir daha bildirim gönderilmez)&#10;```&#10;&#10;**Toplam süre:** &lt;2 saniye ⚡&#10;&#10;&#10;##  Güvenlik&#10;&#10;### HMAC İmza Doğrulama&#10;&#10;Her webhook isteği otomatik olarak doğrulanır:&#10;&#10;```typescript&#10;const crypto = require('crypto');&#10;const hmac = crypto.createHmac('sha256', WEBHOOK_SECRET);&#10;hmac.update(JSON.stringify(payload));&#10;const expectedSignature = hmac.digest('hex');&#10;&#10;// x-webhook-signature header ile karşılaştır&#10;if (receivedSignature === expectedSignature) {&#10;  // Geçerli webhook ✅&#10;} else {&#10;  // Geçersiz! ❌&#10;}&#10;```&#10;&#10;### Tek Bildirim Garantisi&#10;&#10;Her kullanıcıya sadece bir kez bildirim gönderilir:&#10;&#10;```typescript&#10;const notifiedUsers: Record&lt;string, boolean&gt; = {};&#10;&#10;if (notifiedUsers[userUuid]) {&#10;  // Daha önce bildirildi, atla&#10;  return;&#10;}&#10;&#10;// Bildirim gönder&#10;await bot.api.sendMessage(...);&#10;&#10;// İşaretle&#10;notifiedUsers[userUuid] = true;&#10;```&#10;&#10;##  Bildirim Mesajı&#10;&#10;```&#10;⚠️ Hesabınız kısıtlandı!&#10;&#10;Trafik kotanız doldu.&#10;&#10;Hesap detaylarınızı görmek için aşağıdaki butona tıklayın.&#10;&#10;[ Hesap Bilgilerim]&#10;```&#10;&#10;Kullanıcı butona tıkladığında:&#10;- Hesap durumu&#10;- Kalan trafik&#10;- Bitiş tarihi&#10;- Happ CryptoLink&#10;&#10;##  Test Senaryoları&#10;&#10;### 1. Trafik Aşımı Testi&#10;&#10;```bash&#10;# RemnaWave panelinden bir kullanıcının trafiğini limite çek&#10;# Webhook otomatik gönderilecek&#10;# Bot kullanıcıya bildirim atacak&#10;```&#10;&#10;### 2. Abonelik Bitişi Testi&#10;&#10;```bash&#10;# RemnaWave panelinden bir kullanıcının expireAt tarihini geçmişe al&#10;# Webhook otomatik gönderilecek&#10;# Bot kullanıcıya bildirim atacak&#10;```&#10;&#10;### 3. Manuel Test&#10;&#10;```bash&#10;curl -X POST &quot;http://localhost:3000/internal/test-webhook/YOUR_TELEGRAM_ID&quot; \&#10;  -H &quot;x-internal-token: YOUR_INTERNAL_TOKEN&quot; \&#10;  -H &quot;Content-Type: application/json&quot; \&#10;  -d '{&quot;reason&quot;:&quot;Manuel test&quot;}'&#10;```&#10;&#10;##  Dokümantasyon&#10;&#10;- **Webhook Detayları:** [WEBHOOK_GUIDE.md](./WEBHOOK_GUIDE.md)&#10;- **RemnaWave Docs:** https://docs.rw/docs/features/webhooks&#10;&#10;##  Sorun Giderme&#10;&#10;### Webhook Gelmiyor&#10;&#10;1. RemnaWave panel webhook ayarlarını kontrol edin&#10;2. URL'nin doğru ve erişilebilir olduğundan emin olun&#10;3. SSL sertifikası geçerli olmalı (HTTPS zorunlu)&#10;4. Firewall ayarlarını kontrol edin&#10;&#10;### &quot;Invalid signature&quot; Hatası&#10;&#10;```bash&#10;# .env dosyasındaki WEBHOOK_SECRET ile&#10;# RemnaWave panelindeki secret aynı olmalı&#10;&#10;# Boşluk veya özel karakter hatası olabilir&#10;# Secret'i kopyala-yapıştır yapın&#10;```&#10;&#10;### Bildirim Gönderilmiyor&#10;&#10;1. Kullanıcının `telegramId` alanı dolu mu?&#10;2. Kullanıcı botu engellemiş olabilir&#10;3. Kullanıcıya daha önce bildirim gönderilmiş (tek seferlik)&#10;4. Server loglarını kontrol edin&#10;&#10;### Logları Kontrol Edin&#10;&#10;```bash&#10;# Backend logları&#10;docker logs telegram-bot -f&#10;&#10;# Aramalar:&#10;# ✅ &quot;Webhook event received: user.limited&quot;&#10;# ✅ &quot;Notification sent to user...&quot;&#10;# ⚠️  &quot;User has no telegramId&quot;&#10;# ❌ &quot;Invalid webhook signature&quot;&#10;```&#10;&#10;## ✨ Sonraki Adımlar&#10;&#10;- [ ] Production'da test edin&#10;- [ ] RemnaWave panel webhook loglarını inceleyin&#10;- [ ] Telegram bildirimlerini doğrulayın&#10;- [ ] Monitoring ekleyin (opsiyonel)&#10;- [ ] Redis/DB ile kalıcı bildirim geçmişi (opsiyonel)&#10;&#10;##  İpuçları&#10;&#10;1. **SSL sertifikası zorunlu** - Webhook için HTTPS kullanılmalı&#10;2. **Test ortamında ngrok kullanabilirsiniz** - Lokal test için&#10;3. **Logları takip edin** - İlk günlerde sorun tespiti için önemli&#10;4. **Secret güvenliğini koruyun** - `.env` dosyası git'e commit edilmemeli&#10;5. **RemnaWave panel webhook loglarını kontrol edin** - Başarılı/başarısız istekler görünür&#10;&#10;##  Tebrikler!&#10;&#10;Webhook entegrasyonu tamamlandı! Artık kullanıcılarınız hesapları kısıtlandığında anında bildirim alacaklar.&#10;&#10;**Soru/sorun için:** Dokümantasyonu okuyun veya server loglarını kontrol edin.&#10;&#10;" />
              <option name="updatedContent" value="# Hızlı Başlangıç - Webhook Bildirim Sistemi&#10;&#10;## ✅ Tamamlandı&#10;&#10;Webhook entegrasyonu başarıyla eklendi! RemnaWave paneli kullanıcı durumu değiştiğinde otomatik olarak Telegram bildirimi gönderilecek.&#10;&#10;##  Dosyalar&#10;&#10;- ✅ `backend/src/webhook.ts` - Webhook handler&#10;- ✅ `backend/src/index.ts` - Webhook endpoint: `POST /webhook/remnawave`&#10;- ✅ `backend/WEBHOOK_GUIDE.md` - Detaylı webhook kurulum rehberi&#10;- ✅ `backend/.env.production` - Ortam değişkenleri&#10;&#10;##  Kurulum Adımları&#10;&#10;### 1. Webhook Secret Oluşturun&#10;&#10;```bash&#10;# Güçlü bir secret oluşturun&#10;openssl rand -hex 32&#10;```&#10;&#10;### 2. Environment Değişkenlerini Ayarlayın&#10;&#10;`.env.production` dosyasına ekleyin:&#10;&#10;```bash&#10;# Webhook (Gerçek zamanlı bildirimler)&#10;WEBHOOK_SECRET=your_generated_secret_here&#10;&#10;&#10;# Diğer zorunlu değişkenler&#10;API_BASE_URL=https://remnawave.karatatar.com&#10;API_TOKEN=your_api_token&#10;BOT_TOKEN=your_telegram_bot_token&#10;INTERNAL_NOTIFY_TOKEN=your_test_token&#10;```&#10;&#10;### 3. RemnaWave Panelinde Webhook Ayarlayın&#10;&#10;**Adım 1:** RemnaWave panel → Settings → Webhooks&#10;&#10;**Adım 2:** Yeni webhook ekleyin:&#10;- **URL:** `https://telegram-ts-bot-backend.karatatar.com/endpoint`&#10;- **Secret:** Yukarıda oluşturduğunuz secret&#10;- **Events:** Tüm eventler (backend otomatik filtreleyecek)&#10;&#10;**Adım 3:** Kaydet ve test edin&#10;&#10;### 4. Backend'i Deploy Edin&#10;&#10;```bash&#10;cd backend&#10;npm install&#10;npm run build&#10;npm start&#10;&#10;# Veya docker ile&#10;docker build -t telegram-bot .&#10;docker run -p 3000:3000 telegram-bot&#10;```&#10;&#10;### 5. Test Edin&#10;&#10;```bash&#10;# Health check&#10;curl https://your-domain.com/health&#10;&#10;# Manuel webhook testi&#10;curl -X POST &quot;https://your-domain.com/webhook/remnawave&quot; \&#10;  -H &quot;Content-Type: application/json&quot; \&#10;  -d '{&#10;    &quot;event&quot;: &quot;user.limited&quot;,&#10;    &quot;timestamp&quot;: &quot;2024-11-21T10:30:00Z&quot;,&#10;    &quot;data&quot;: {&#10;      &quot;user&quot;: {&#10;        &quot;uuid&quot;: &quot;test-uuid&quot;,&#10;        &quot;username&quot;: &quot;test_user&quot;,&#10;        &quot;status&quot;: &quot;LIMITED&quot;,&#10;        &quot;telegramId&quot;: YOUR_TELEGRAM_ID&#10;      }&#10;    }&#10;  }'&#10;```&#10;&#10;##  Nasıl Çalışır?&#10;&#10;```&#10;Kullanıcı trafik limitini aşar (örn: 2GB)&#10;    ↓&#10;RemnaWave paneli status değiştirir: ACTIVE → LIMITED&#10;    ↓&#10;Panel webhook gönderir: POST https://telegram-ts-bot-backend.karatatar.com/endpoint&#10;    ↓&#10;Backend webhook'u alır ve imzayı doğrular (HMAC SHA256)&#10;    ↓&#10;Kullanıcının telegramId'si kontrol edilir&#10;    ↓&#10;Telegram bildirimi gönderilir (&lt;1 saniye)&#10;    ↓&#10;Kullanıcı işaretlenir (bir daha bildirim gönderilmez)&#10;```&#10;&#10;**Toplam süre:** &lt;2 saniye ⚡&#10;&#10;&#10;##  Güvenlik&#10;&#10;### HMAC İmza Doğrulama&#10;&#10;Her webhook isteği otomatik olarak doğrulanır:&#10;&#10;```typescript&#10;const crypto = require('crypto');&#10;const hmac = crypto.createHmac('sha256', WEBHOOK_SECRET);&#10;hmac.update(JSON.stringify(payload));&#10;const expectedSignature = hmac.digest('hex');&#10;&#10;// x-webhook-signature header ile karşılaştır&#10;if (receivedSignature === expectedSignature) {&#10;  // Geçerli webhook ✅&#10;} else {&#10;  // Geçersiz! ❌&#10;}&#10;```&#10;&#10;### Tek Bildirim Garantisi&#10;&#10;Her kullanıcıya sadece bir kez bildirim gönderilir:&#10;&#10;```typescript&#10;const notifiedUsers: Record&lt;string, boolean&gt; = {};&#10;&#10;if (notifiedUsers[userUuid]) {&#10;  // Daha önce bildirildi, atla&#10;  return;&#10;}&#10;&#10;// Bildirim gönder&#10;await bot.api.sendMessage(...);&#10;&#10;// İşaretle&#10;notifiedUsers[userUuid] = true;&#10;```&#10;&#10;##  Bildirim Mesajı&#10;&#10;```&#10;⚠️ Hesabınız kısıtlandı!&#10;&#10;Trafik kotanız doldu.&#10;&#10;Hesap detaylarınızı görmek için aşağıdaki butona tıklayın.&#10;&#10;[ Hesap Bilgilerim]&#10;```&#10;&#10;Kullanıcı butona tıkladığında:&#10;- Hesap durumu&#10;- Kalan trafik&#10;- Bitiş tarihi&#10;- Happ CryptoLink&#10;&#10;##  Test Senaryoları&#10;&#10;### 1. Trafik Aşımı Testi&#10;&#10;```bash&#10;# RemnaWave panelinden bir kullanıcının trafiğini limite çek&#10;# Webhook otomatik gönderilecek&#10;# Bot kullanıcıya bildirim atacak&#10;```&#10;&#10;### 2. Abonelik Bitişi Testi&#10;&#10;```bash&#10;# RemnaWave panelinden bir kullanıcının expireAt tarihini geçmişe al&#10;# Webhook otomatik gönderilecek&#10;# Bot kullanıcıya bildirim atacak&#10;```&#10;&#10;### 3. Manuel Test&#10;&#10;```bash&#10;curl -X POST &quot;http://localhost:3000/internal/test-webhook/YOUR_TELEGRAM_ID&quot; \&#10;  -H &quot;x-internal-token: YOUR_INTERNAL_TOKEN&quot; \&#10;  -H &quot;Content-Type: application/json&quot; \&#10;  -d '{&quot;reason&quot;:&quot;Manuel test&quot;}'&#10;```&#10;&#10;##  Dokümantasyon&#10;&#10;- **Webhook Detayları:** [WEBHOOK_GUIDE.md](./WEBHOOK_GUIDE.md)&#10;- **RemnaWave Docs:** https://docs.rw/docs/features/webhooks&#10;&#10;##  Sorun Giderme&#10;&#10;### Webhook Gelmiyor&#10;&#10;1. RemnaWave panel webhook ayarlarını kontrol edin&#10;2. URL'nin doğru ve erişilebilir olduğundan emin olun&#10;3. SSL sertifikası geçerli olmalı (HTTPS zorunlu)&#10;4. Firewall ayarlarını kontrol edin&#10;&#10;### &quot;Invalid signature&quot; Hatası&#10;&#10;```bash&#10;# .env dosyasındaki WEBHOOK_SECRET ile&#10;# RemnaWave panelindeki secret aynı olmalı&#10;&#10;# Boşluk veya özel karakter hatası olabilir&#10;# Secret'i kopyala-yapıştır yapın&#10;```&#10;&#10;### Bildirim Gönderilmiyor&#10;&#10;1. Kullanıcının `telegramId` alanı dolu mu?&#10;2. Kullanıcı botu engellemiş olabilir&#10;3. Kullanıcıya daha önce bildirim gönderilmiş (tek seferlik)&#10;4. Server loglarını kontrol edin&#10;&#10;### Logları Kontrol Edin&#10;&#10;```bash&#10;# Backend logları&#10;docker logs telegram-bot -f&#10;&#10;# Aramalar:&#10;# ✅ &quot;Webhook event received: user.limited&quot;&#10;# ✅ &quot;Notification sent to user...&quot;&#10;# ⚠️  &quot;User has no telegramId&quot;&#10;# ❌ &quot;Invalid webhook signature&quot;&#10;```&#10;&#10;## ✨ Sonraki Adımlar&#10;&#10;- [ ] Production'da test edin&#10;- [ ] RemnaWave panel webhook loglarını inceleyin&#10;- [ ] Telegram bildirimlerini doğrulayın&#10;- [ ] Monitoring ekleyin (opsiyonel)&#10;- [ ] Redis/DB ile kalıcı bildirim geçmişi (opsiyonel)&#10;&#10;##  İpuçları&#10;&#10;1. **SSL sertifikası zorunlu** - Webhook için HTTPS kullanılmalı&#10;2. **Test ortamında ngrok kullanabilirsiniz** - Lokal test için&#10;3. **Logları takip edin** - İlk günlerde sorun tespiti için önemli&#10;4. **Secret güvenliğini koruyun** - `.env` dosyası git'e commit edilmemeli&#10;5. **RemnaWave panel webhook loglarını kontrol edin** - Başarılı/başarısız istekler görünür&#10;&#10;##  Tebrikler!&#10;&#10;Webhook entegrasyonu tamamlandı! Artık kullanıcılarınız hesapları kısıtlandığında anında bildirim alacaklar.&#10;&#10;**Soru/sorun için:** Dokümantasyonu okuyun veya server loglarını kontrol edin.&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/README.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/README.md" />
              <option name="originalContent" value="# Telegram Bot - Webhook Bildirim Sistemi&#10;&#10;##  Amaç&#10;&#10;RemnaWave paneli kullanıcı hesapları kısıtlandığında (trafik aşımı, abonelik bitişi) otomatik olarak Telegram üzerinden gerçek zamanlı bildirim gönderir.&#10;&#10;## ⚡ Özellikler&#10;&#10;- **Gerçek Zamanlı** - Webhook ile anında bildirim (&lt;2 saniye)&#10;- **Tek Seferlik** - Her kullanıcıya sadece bir kez mesaj&#10;- **Güvenli** - HMAC SHA256 imza doğrulama&#10;- **Minimal** - Sadece webhook, gereksiz kod yok&#10;&#10;##  Dosya Yapısı&#10;&#10;```&#10;backend/&#10;├── src/&#10;│   ├── index.ts           # Ana uygulama, bot ve endpoint'ler&#10;│   ├── webhook.ts         # Webhook handler (gerçek zamanlı bildirimler)&#10;│   └── api.ts             # API client fonksiyonları&#10;├── .env.production        # Ortam değişkenleri&#10;├── QUICKSTART.md          # Hızlı başlangıç kılavuzu&#10;└── WEBHOOK_GUIDE.md       # Detaylı webhook dokümantasyonu&#10;```&#10;&#10;##  Hızlı Başlangıç&#10;&#10;### 1. Webhook Secret Oluşturun&#10;&#10;```bash&#10;openssl rand -hex 32&#10;```&#10;&#10;### 2. Environment Değişkenlerini Ayarlayın&#10;&#10;```bash&#10;WEBHOOK_SECRET=your_generated_secret&#10;API_BASE_URL=https://remnawave.karatatar.com&#10;API_TOKEN=your_api_token&#10;BOT_TOKEN=your_telegram_bot_token&#10;```&#10;&#10;### 3. RemnaWave Panelinde Webhook Ekleyin&#10;&#10;- **URL:** `https://your-domain.com/webhook/remnawave`&#10;- **Secret:** Yukarıdaki secret&#10;- **Events:** user.status.changed, user.limited, user.expired, user.disabled&#10;&#10;### 4. Deploy&#10;&#10;```bash&#10;npm install&#10;npm run build&#10;npm start&#10;```&#10;&#10;##  Dokümantasyon&#10;&#10;- **Hızlı Başlangıç:** [QUICKSTART.md](./QUICKSTART.md)&#10;- **Webhook Detayları:** [WEBHOOK_GUIDE.md](./WEBHOOK_GUIDE.md)&#10;- **RemnaWave Docs:** https://docs.rw/docs/features/webhooks&#10;&#10;##  Endpoint'ler&#10;&#10;### Webhook Endpoint&#10;```&#10;POST /endpoint&#10;```&#10;RemnaWave panelinden gelen webhook eventlerini işler.&#10;&#10;### Test Endpoint&#10;```&#10;POST /internal/test-webhook/:telegramId&#10;Header: x-internal-token&#10;```&#10;Manuel test için kullanılır.&#10;&#10;### Health Check&#10;```&#10;GET /health&#10;```&#10;Servis durumunu kontrol eder.&#10;&#10;##  Bildirim Akışı&#10;&#10;```&#10;RemnaWave: User Status Changed&#10;    ↓ (Webhook gönder)&#10;Backend: Webhook Al &amp; Doğrula&#10;    ↓ (HMAC SHA256)&#10;Backend: Telegram ID Kontrol&#10;    ↓ (Var mı?)&#10;Telegram: Bildirim Gönder&#10;    ↓ (&lt;1 saniye)&#10;User: Bildirim Al&#10;    ↓ (&quot;Hesap Bilgilerim&quot; butonuna tıkla)&#10;Bot: Hesap Detaylarını Göster&#10;```&#10;&#10;##  Güvenlik&#10;&#10;- HMAC SHA256 imza doğrulama&#10;- Header-based authentication (x-webhook-signature)&#10;- Tek seferlik bildirim (spam önleme)&#10;- Environment-based secrets&#10;&#10;##  Test&#10;&#10;```bash&#10;# Manuel test&#10;curl -X POST &quot;http://localhost:3000/internal/test-webhook/YOUR_TELEGRAM_ID&quot; \&#10;  -H &quot;x-internal-token: YOUR_SECRET&quot; \&#10;  -H &quot;Content-Type: application/json&quot; \&#10;  -d '{&quot;reason&quot;:&quot;Test&quot;}'&#10;```&#10;&#10;##  Bildirim Mesajı&#10;&#10;```&#10;⚠️ Hesabınız kısıtlandı!&#10;&#10;Trafik kotanız doldu.&#10;&#10;Hesap detaylarınızı görmek için aşağıdaki butona tıklayın.&#10;&#10;[ Hesap Bilgilerim]&#10;```&#10;&#10;##  Önceki Durumdan Fark&#10;&#10;**ÖNCE (Notifier):**&#10;- ❌ 5 dakika gecikme&#10;- ❌ Periyodik API kontrolü&#10;- ❌ Yüksek kaynak kullanımı&#10;- ❌ Karmaşık kod&#10;&#10;**ŞIMDI (Webhook):**&#10;- ✅ &lt;2 saniye gecikme&#10;- ✅ Gerçek zamanlı&#10;- ✅ Minimal kaynak&#10;- ✅ Temiz kod&#10;&#10;##  Destek&#10;&#10;Sorun yaşarsanız:&#10;1. [WEBHOOK_GUIDE.md](./WEBHOOK_GUIDE.md) dokümantasyonunu okuyun&#10;2. Server loglarını kontrol edin&#10;3. RemnaWave panel webhook loglarını inceleyin&#10;&#10;" />
              <option name="updatedContent" value="# Telegram Bot - Webhook Bildirim Sistemi&#10;&#10;##  Amaç&#10;&#10;RemnaWave paneli kullanıcı hesapları kısıtlandığında (trafik aşımı, abonelik bitişi) otomatik olarak Telegram üzerinden gerçek zamanlı bildirim gönderir.&#10;&#10;## ⚡ Özellikler&#10;&#10;- **Gerçek Zamanlı** - Webhook ile anında bildirim (&lt;2 saniye)&#10;- **Tek Seferlik** - Her kullanıcıya sadece bir kez mesaj&#10;- **Güvenli** - HMAC SHA256 imza doğrulama&#10;- **Minimal** - Sadece webhook, gereksiz kod yok&#10;&#10;##  Dosya Yapısı&#10;&#10;```&#10;backend/&#10;├── src/&#10;│   ├── index.ts           # Ana uygulama, bot ve endpoint'ler&#10;│   ├── webhook.ts         # Webhook handler (gerçek zamanlı bildirimler)&#10;│   └── api.ts             # API client fonksiyonları&#10;├── .env.production        # Ortam değişkenleri&#10;├── QUICKSTART.md          # Hızlı başlangıç kılavuzu&#10;└── WEBHOOK_GUIDE.md       # Detaylı webhook dokümantasyonu&#10;```&#10;&#10;##  Hızlı Başlangıç&#10;&#10;### 1. Webhook Secret Oluşturun&#10;&#10;```bash&#10;openssl rand -hex 32&#10;```&#10;&#10;### 2. Environment Değişkenlerini Ayarlayın&#10;&#10;```bash&#10;WEBHOOK_SECRET=your_generated_secret&#10;API_BASE_URL=https://remnawave.karatatar.com&#10;API_TOKEN=your_api_token&#10;BOT_TOKEN=your_telegram_bot_token&#10;```&#10;&#10;### 3. RemnaWave Panelinde Webhook Ekleyin&#10;&#10;- **URL:** `https://telegram-ts-bot-backend.karatatar.com/endpoint`&#10;- **Secret:** Yukarıdaki secret&#10;- **Events:** Tüm eventler (backend otomatik filtreleyecek)&#10;&#10;### 4. Deploy&#10;&#10;```bash&#10;npm install&#10;npm run build&#10;npm start&#10;```&#10;&#10;##  Dokümantasyon&#10;&#10;- **Hızlı Başlangıç:** [QUICKSTART.md](./QUICKSTART.md)&#10;- **Webhook Detayları:** [WEBHOOK_GUIDE.md](./WEBHOOK_GUIDE.md)&#10;- **RemnaWave Docs:** https://docs.rw/docs/features/webhooks&#10;&#10;##  Endpoint'ler&#10;&#10;### Webhook Endpoint&#10;```&#10;POST /endpoint&#10;```&#10;RemnaWave panelinden gelen webhook eventlerini işler.&#10;&#10;### Test Endpoint&#10;```&#10;POST /internal/test-webhook/:telegramId&#10;Header: x-internal-token&#10;```&#10;Manuel test için kullanılır.&#10;&#10;### Health Check&#10;```&#10;GET /health&#10;```&#10;Servis durumunu kontrol eder.&#10;&#10;##  Bildirim Akışı&#10;&#10;```&#10;RemnaWave: User Status Changed&#10;    ↓ (Webhook gönder)&#10;Backend: Webhook Al &amp; Doğrula&#10;    ↓ (HMAC SHA256)&#10;Backend: Telegram ID Kontrol&#10;    ↓ (Var mı?)&#10;Telegram: Bildirim Gönder&#10;    ↓ (&lt;1 saniye)&#10;User: Bildirim Al&#10;    ↓ (&quot;Hesap Bilgilerim&quot; butonuna tıkla)&#10;Bot: Hesap Detaylarını Göster&#10;```&#10;&#10;##  Güvenlik&#10;&#10;- HMAC SHA256 imza doğrulama&#10;- Header-based authentication (x-webhook-signature)&#10;- Tek seferlik bildirim (spam önleme)&#10;- Environment-based secrets&#10;&#10;##  Test&#10;&#10;```bash&#10;# Manuel test&#10;curl -X POST &quot;http://localhost:3000/internal/test-webhook/YOUR_TELEGRAM_ID&quot; \&#10;  -H &quot;x-internal-token: YOUR_SECRET&quot; \&#10;  -H &quot;Content-Type: application/json&quot; \&#10;  -d '{&quot;reason&quot;:&quot;Test&quot;}'&#10;```&#10;&#10;##  Bildirim Mesajı&#10;&#10;```&#10;⚠️ Hesabınız kısıtlandı!&#10;&#10;Trafik kotanız doldu.&#10;&#10;Hesap detaylarınızı görmek için aşağıdaki butona tıklayın.&#10;&#10;[ Hesap Bilgilerim]&#10;```&#10;&#10;##  Önceki Durumdan Fark&#10;&#10;**ÖNCE (Notifier):**&#10;- ❌ 5 dakika gecikme&#10;- ❌ Periyodik API kontrolü&#10;- ❌ Yüksek kaynak kullanımı&#10;- ❌ Karmaşık kod&#10;&#10;**ŞIMDI (Webhook):**&#10;- ✅ &lt;2 saniye gecikme&#10;- ✅ Gerçek zamanlı&#10;- ✅ Minimal kaynak&#10;- ✅ Temiz kod&#10;&#10;##  Destek&#10;&#10;Sorun yaşarsanız:&#10;1. [WEBHOOK_GUIDE.md](./WEBHOOK_GUIDE.md) dokümantasyonunu okuyun&#10;2. Server loglarını kontrol edin&#10;3. RemnaWave panel webhook loglarını inceleyin&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/REMNAWAVE_WEBHOOK_SETUP.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/REMNAWAVE_WEBHOOK_SETUP.md" />
              <option name="originalContent" value="#  RemnaWave Panel - Webhook Kurulumu&#10;&#10;## ✅ Adım Adım Kurulum&#10;&#10;### 1. RemnaWave Paneline Girin&#10;```&#10;https://remnawave.karatatar.com&#10;```&#10;&#10;### 2. Webhook Ayarlarına Gidin&#10;```&#10;Settings → Webhooks → Add New Webhook&#10;```&#10;&#10;### 3. Formu Doldurun&#10;&#10;####  URL Alanı:&#10;```&#10;https://telegram-ts-bot-backend.karatatar.com/endpoint&#10;```&#10;**DİKKAT:** &#10;- ✅ Doğru: `/endpoint`&#10;- ❌ Yanlış: `/webhook/remnawave`&#10;- ❌ Yanlış: `/webhook`&#10;&#10;####  Secret Alanı:&#10;```&#10;9807bd3a6533bc3c72d9d67a904427811e433415de1300b8b76d80e07a8aa476a08bf2c30bc7252eb810b81fb8281de2d149b41350fbc2a17c9cc015c489498f&#10;```&#10;**NOT:** Bu secret `.env.production` dosyasındaki `WEBHOOK_SECRET` ile aynı olmalı!&#10;&#10;####  Events (Olaylar):&#10;Şu olayları seçin:&#10;&#10;- ☑️ `user.status.changed` - Kullanıcı durumu değiştiğinde&#10;- ☑️ `user.limited` - Trafik limiti aşıldığında&#10;- ☑️ `user.expired` - Abonelik süresi dolduğunda&#10;- ☑️ `user.disabled` - Kullanıcı devre dışı bırakıldığında&#10;&#10;### 4. Kaydet&#10;&#10;&quot;Save&quot; veya &quot;Create&quot; butonuna tıklayın.&#10;&#10;---&#10;&#10;##  Test Etme&#10;&#10;### Manuel Test (Backend'den)&#10;&#10;Backend sunucunuz çalışırken terminalden:&#10;&#10;```bash&#10;curl -X POST &quot;https://telegram-ts-bot-backend.karatatar.com/internal/test-webhook/YOUR_TELEGRAM_ID&quot; \&#10;  -H &quot;x-internal-token: YOUR_INTERNAL_NOTIFY_TOKEN&quot; \&#10;  -H &quot;Content-Type: application/json&quot; \&#10;  -d '{&quot;reason&quot;:&quot;Test bildirimi&quot;}'&#10;```&#10;&#10;**Not:** `YOUR_TELEGRAM_ID` yerine kendi Telegram ID'nizi yazın.&#10;&#10;### Canlı Test (RemnaWave'den)&#10;&#10;1. RemnaWave panelinde bir test kullanıcısı oluşturun&#10;2. Kullanıcının trafik limitini çok düşük ayarlayın (örn: 1 MB)&#10;3. O kullanıcı ile biraz veri kullanın&#10;4. Limit aşıldığında Telegram'da bildirim almalısınız!&#10;&#10;---&#10;&#10;##  Webhook Durumunu Kontrol&#10;&#10;RemnaWave panelinde webhook'u oluşturduktan sonra:&#10;&#10;```&#10;Settings → Webhooks → [Webhook'unuzu seçin] → Logs&#10;```&#10;&#10;Burada webhook isteklerini görebilirsiniz:&#10;&#10;### ✅ Başarılı İstek Örneği:&#10;```&#10;Status: 200 OK&#10;Response Time: 156ms&#10;Event: user.limited&#10;```&#10;&#10;### ❌ Başarısız İstek Örneği:&#10;```&#10;Status: 401 Unauthorized&#10;Response Time: 45ms&#10;Error: Invalid signature&#10;```&#10;&#10;**Çözüm:** Secret'lerin aynı olduğundan emin olun!&#10;&#10;---&#10;&#10;##  Sorun Giderme&#10;&#10;### Webhook çalışmıyor?&#10;&#10;**1. URL'i kontrol edin:**&#10;```bash&#10;# Doğru:&#10;https://telegram-ts-bot-backend.karatatar.com/webhook/remnawave&#10;&#10;# Yanlış:&#10;https://telegram-ts-bot-backend.karatatar.com/endpoint&#10;https://telegram-ts-bot-backend.karatatar.com/webhook&#10;```&#10;&#10;**2. Backend çalışıyor mu?**&#10;```bash&#10;curl https://telegram-ts-bot-backend.karatatar.com/health&#10;# Yanıt: {&quot;status&quot;:&quot;ok&quot;,&quot;uptime&quot;:12345}&#10;```&#10;&#10;**3. Secret doğru mu?**&#10;```bash&#10;# .env.production dosyasındaki WEBHOOK_SECRET&#10;# = &#10;# RemnaWave panelindeki Secret alanı&#10;&#10;# İkisi de aynı olmalı!&#10;```&#10;&#10;**4. SSL var mı?**&#10;- ✅ `https://` ile başlamalı&#10;- ❌ `http://` çalışmaz&#10;&#10;**5. Firewall/Güvenlik?**&#10;RemnaWave'in backend sunucunuza erişebildiğinden emin olun.&#10;&#10;---&#10;&#10;##  Kontrol Listesi&#10;&#10;- [ ] URL: `https://telegram-ts-bot-backend.karatatar.com/webhook/remnawave`&#10;&#10;- [ ] RemnaWave panelinde webhook oluşturuldu&#10;- [ ] URL: `https://telegram-ts-bot-backend.karatatar.com/endpoint`&#10;- [ ] Secret: `.env.production` ile aynı&#10;- [ ] Events: 4 event seçildi (status.changed, limited, expired, disabled)&#10;- [ ] Backend sunucu çalışıyor&#10;- [ ] `/health` endpoint'i 200 OK dönüyor&#10;- [ ] Test webhook başarılı&#10;- [ ] RemnaWave panel → Webhook Logs → İstekler gözüküyor&#10;&#10;Hepsi ✅ ise kurulum tamam! &#10;&#10;---&#10;&#10;##  Sonraki Adımlar&#10;&#10;1. **Canlı Test:** Bir kullanıcının limitini aşırıp Telegram bildirimi alın&#10;2. **Monitoring:** İlk günlerde webhook loglarını takip edin&#10;3. **Production:** Her şey çalışıyorsa gerçek kullanıcılara açın!&#10;&#10;---&#10;&#10;##  İpucu&#10;&#10;RemnaWave panelinde webhook'u &quot;Test&quot; butonu varsa, onu kullanarak hemen test edebilirsiniz. Backend sunucu loglarında şunu göreceksiniz:&#10;&#10;```&#10;Webhook event received: user.limited&#10;✅ Notification sent to user test_user (123456789)&#10;```&#10;&#10;Başarılar! &#10;&#10;" />
              <option name="updatedContent" value="#  RemnaWave Panel - Webhook Kurulumu&#10;&#10;## ✅ Adım Adım Kurulum&#10;&#10;### 1. RemnaWave Paneline Girin&#10;```&#10;https://remnawave.karatatar.com&#10;```&#10;&#10;### 2. Webhook Ayarlarına Gidin&#10;```&#10;Settings → Webhooks → Add New Webhook&#10;```&#10;&#10;### 3. Formu Doldurun&#10;&#10;####  URL Alanı:&#10;```&#10;https://telegram-ts-bot-backend.karatatar.com/endpoint&#10;```&#10;**DİKKAT:** &#10;- ✅ Doğru: `/endpoint`&#10;- ❌ Yanlış: `/webhook/remnawave`&#10;- ❌ Yanlış: `/webhook`&#10;&#10;####  Secret Alanı:&#10;```&#10;9807bd3a6533bc3c72d9d67a904427811e433415de1300b8b76d80e07a8aa476a08bf2c30bc7252eb810b81fb8281de2d149b41350fbc2a17c9cc015c489498f&#10;```&#10;**NOT:** Bu secret `.env.production` dosyasındaki `WEBHOOK_SECRET` ile aynı olmalı!&#10;&#10;####  Events (Olaylar):&#10;**RemnaWave panelinde event seçimi yoksa:**&#10;- Tüm webhook eventlerini gönderin&#10;- Backend otomatik olarak sadece gerekli eventleri işler:&#10;  - ✅ `user.status.changed`&#10;  - ✅ `user.limited`&#10;  - ✅ `user.expired`&#10;  - ✅ `user.disabled`&#10;- Diğer eventler (user.created, user.updated, vb.) otomatik olarak atlanır&#10;&#10;### 4. Kaydet&#10;&#10;&quot;Save&quot; veya &quot;Create&quot; butonuna tıklayın.&#10;&#10;---&#10;&#10;##  Test Etme&#10;&#10;### Manuel Test (Backend'den)&#10;&#10;Backend sunucunuz çalışırken terminalden:&#10;&#10;```bash&#10;curl -X POST &quot;https://telegram-ts-bot-backend.karatatar.com/internal/test-webhook/YOUR_TELEGRAM_ID&quot; \&#10;  -H &quot;x-internal-token: YOUR_INTERNAL_NOTIFY_TOKEN&quot; \&#10;  -H &quot;Content-Type: application/json&quot; \&#10;  -d '{&quot;reason&quot;:&quot;Test bildirimi&quot;}'&#10;```&#10;&#10;**Not:** `YOUR_TELEGRAM_ID` yerine kendi Telegram ID'nizi yazın.&#10;&#10;### Canlı Test (RemnaWave'den)&#10;&#10;1. RemnaWave panelinde bir test kullanıcısı oluşturun&#10;2. Kullanıcının trafik limitini çok düşük ayarlayın (örn: 1 MB)&#10;3. O kullanıcı ile biraz veri kullanın&#10;4. Limit aşıldığında Telegram'da bildirim almalısınız!&#10;&#10;---&#10;&#10;##  Webhook Durumunu Kontrol&#10;&#10;RemnaWave panelinde webhook'u oluşturduktan sonra:&#10;&#10;```&#10;Settings → Webhooks → [Webhook'unuzu seçin] → Logs&#10;```&#10;&#10;Burada webhook isteklerini görebilirsiniz:&#10;&#10;### ✅ Başarılı İstek Örneği:&#10;```&#10;Status: 200 OK&#10;Response Time: 156ms&#10;Event: user.limited&#10;```&#10;&#10;### ❌ Başarısız İstek Örneği:&#10;```&#10;Status: 401 Unauthorized&#10;Response Time: 45ms&#10;Error: Invalid signature&#10;```&#10;&#10;**Çözüm:** Secret'lerin aynı olduğundan emin olun!&#10;&#10;---&#10;&#10;##  Sorun Giderme&#10;&#10;### Webhook çalışmıyor?&#10;&#10;**1. URL'i kontrol edin:**&#10;```bash&#10;# Doğru:&#10;https://telegram-ts-bot-backend.karatatar.com/endpoint&#10;&#10;# Yanlış:&#10;https://telegram-ts-bot-backend.karatatar.com/webhook/remnawave&#10;https://telegram-ts-bot-backend.karatatar.com/webhook&#10;```&#10;&#10;**2. Backend çalışıyor mu?**&#10;```bash&#10;curl https://telegram-ts-bot-backend.karatatar.com/health&#10;# Yanıt: {&quot;status&quot;:&quot;ok&quot;,&quot;uptime&quot;:12345}&#10;```&#10;&#10;**3. Secret doğru mu?**&#10;```bash&#10;# .env.production dosyasındaki WEBHOOK_SECRET&#10;# = &#10;# RemnaWave panelindeki Secret alanı&#10;&#10;# İkisi de aynı olmalı!&#10;```&#10;&#10;**4. SSL var mı?**&#10;- ✅ `https://` ile başlamalı&#10;- ❌ `http://` çalışmaz&#10;&#10;**5. Firewall/Güvenlik?**&#10;RemnaWave'in backend sunucunuza erişebildiğinden emin olun.&#10;&#10;---&#10;&#10;##  Kontrol Listesi&#10;&#10;Webhook kurulumu tamamlandı mı?&#10;&#10;- [ ] RemnaWave panelinde webhook oluşturuldu&#10;- [ ] URL: `https://telegram-ts-bot-backend.karatatar.com/endpoint`&#10;- [ ] Secret: `.env.production` ile aynı&#10;- [ ] Backend sunucu çalışıyor&#10;- [ ] `/health` endpoint'i 200 OK dönüyor&#10;- [ ] Test webhook başarılı&#10;- [ ] RemnaWave panel → Webhook Logs → İstekler gözüküyor&#10;&#10;**NOT:** Event seçimi gerekmiyor, backend otomatik filtreleyecek!&#10;&#10;Hepsi ✅ ise kurulum tamam! &#10;&#10;---&#10;&#10;##  Sonraki Adımlar&#10;&#10;1. **Canlı Test:** Bir kullanıcının limitini aşırıp Telegram bildirimi alın&#10;2. **Monitoring:** İlk günlerde webhook loglarını takip edin&#10;3. **Production:** Her şey çalışıyorsa gerçek kullanıcılara açın!&#10;&#10;---&#10;&#10;##  İpucu&#10;&#10;RemnaWave panelinde webhook'u &quot;Test&quot; butonu varsa, onu kullanarak hemen test edebilirsiniz. Backend sunucu loglarında şunu göreceksiniz:&#10;&#10;```&#10;Webhook event received: user.limited&#10;✅ Notification sent to user test_user (123456789)&#10;```&#10;&#10;Başarılar! &#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/SETUP.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/SETUP.md" />
              <option name="originalContent" value="# ⚡ Webhook Kurulum - 3 Basit Adım&#10;&#10;## 1️⃣ Webhook Secret Oluştur&#10;&#10;```bash&#10;openssl rand -hex 32&#10;```&#10;&#10;Çıkan secret'i kopyala ve `.env.production` dosyasına yapıştır:&#10;&#10;```bash&#10;WEBHOOK_SECRET=burayakopyalanan_secret_yazilacak&#10;```&#10;&#10;## 2️⃣ RemnaWave Panelinde Webhook Ekle&#10;&#10;RemnaWave Panel → Settings → Webhooks → Add New Webhook&#10;&#10; Formu doldur:&#10;&#10;```&#10;URL: https://telegram-ts-bot-backend.karatatar.com/endpoint&#10;      ↑ Bu sizin backend sunucunuzun adresi + /endpoint&#10;&#10;Secret: [1. adımda oluşturduğun secret]&#10;&#10;Events (seçilecekler):&#10;  ☑ user.status.changed&#10;  ☑ user.limited&#10;  ☑ user.expired&#10;  ☑ user.disabled&#10;```&#10;&#10;**Kaydet**&#10;&#10;## 3️⃣ Test Et&#10;&#10;```bash&#10;# Backend sunucunuz çalışırken bu komutu çalıştırın:&#10;curl -X POST &quot;https://telegram-ts-bot-backend.karatatar.com/internal/test-webhook/YOUR_TELEGRAM_ID&quot; \&#10;  -H &quot;x-internal-token: YOUR_INTERNAL_NOTIFY_TOKEN&quot; \&#10;  -H &quot;Content-Type: application/json&quot; \&#10;  -d '{&quot;reason&quot;:&quot;Test bildirimi&quot;}'&#10;```&#10;&#10;Telegram'da bildirim gelirse ✅ Kurulum tamam!&#10;&#10;---&#10;&#10;## ❓ SSS&#10;&#10;### Webhook URL nereden geliyor?&#10;&#10;`.env.production` dosyasındaki `PUBLIC_BASE_URL` + `/webhook/remnawave`&#10;&#10;```&#10;PUBLIC_BASE_URL=https://telegram-ts-bot-backend.karatatar.com&#10;                         ↓&#10;Webhook URL: https://telegram-ts-bot-backend.karatatar.com/webhook/remnawave&#10;```&#10;&#10;### Secret nerede kullanılacak?&#10;&#10;İki yerde:&#10;1. `.env.production` dosyasında: `WEBHOOK_SECRET=xxx`&#10;2. RemnaWave panelinde: Secret alanına aynı değer&#10;&#10;İkisi **AYNI** olmalı!&#10;&#10;### Nasıl çalıştığını görebilir miyim?&#10;&#10;Evet! Backend sunucu loglarını izleyin:&#10;&#10;```bash&#10;# Docker kullanıyorsanız&#10;docker logs -f telegram-bot&#10;&#10;# Normal çalıştırıyorsanız&#10;# Terminal'de göreceksiniz&#10;```&#10;&#10;Kullanıcı durumu değiştiğinde şöyle loglar göreceksiniz:&#10;&#10;```&#10;Webhook event received: user.limited&#10;✅ Notification sent to user john_doe (123456789)&#10;```&#10;&#10;### Çalışmazsa?&#10;&#10;1. **Backend çalışıyor mu?** → `curl https://telegram-ts-bot-backend.karatatar.com/health`&#10;2. **Secret doğru mu?** → .env ve panel'de aynı olmalı&#10;3. **URL doğru mu?** → `/webhook/remnawave` sonunda olmalı&#10;4. **SSL var mı?** → HTTPS olmalı (HTTP olmaz)&#10;5. **Logları kontrol et** → Hata mesajlarını göreceksin&#10;&#10;---&#10;&#10;##  Tamamlandı!&#10;&#10;Artık sistem çalışıyor. Kullanıcı trafiği aştığında veya aboneliği bittiğinde otomatik olarak Telegram bildirimi alacak.&#10;&#10;**Test için:** RemnaWave panelinden bir test kullanıcısının trafiğini limite çekin ve webhook'un çalıştığını görün!&#10;&#10;" />
              <option name="updatedContent" value="# ⚡ Webhook Kurulum - 3 Basit Adım&#10;&#10;## 1️⃣ Webhook Secret Oluştur&#10;&#10;```bash&#10;openssl rand -hex 32&#10;```&#10;&#10;Çıkan secret'i kopyala ve `.env.production` dosyasına yapıştır:&#10;&#10;```bash&#10;WEBHOOK_SECRET=burayakopyalanan_secret_yazilacak&#10;```&#10;&#10;## 2️⃣ RemnaWave Panelinde Webhook Ekle&#10;&#10;RemnaWave Panel → Settings → Webhooks → Add New Webhook&#10;&#10; Formu doldur:&#10;&#10;```&#10;URL: https://telegram-ts-bot-backend.karatatar.com/endpoint&#10;      ↑ Bu sizin backend sunucunuzun adresi + /endpoint&#10;&#10;Secret: [1. adımda oluşturduğun secret]&#10;&#10;NOT: RemnaWave panelinde event seçimi yoksa tüm eventleri gönder.&#10;     Backend otomatik olarak sadece gerekli olanları işler:&#10;     - user.status.changed, user.limited, user.expired, user.disabled&#10;&#10;**Kaydet**&#10;&#10;## 3️⃣ Test Et&#10;&#10;```bash&#10;# Backend sunucunuz çalışırken bu komutu çalıştırın:&#10;curl -X POST &quot;https://telegram-ts-bot-backend.karatatar.com/internal/test-webhook/YOUR_TELEGRAM_ID&quot; \&#10;  -H &quot;x-internal-token: YOUR_INTERNAL_NOTIFY_TOKEN&quot; \&#10;  -H &quot;Content-Type: application/json&quot; \&#10;  -d '{&quot;reason&quot;:&quot;Test bildirimi&quot;}'&#10;```&#10;&#10;Telegram'da bildirim gelirse ✅ Kurulum tamam!&#10;&#10;---&#10;&#10;## ❓ SSS&#10;&#10;### Webhook URL nereden geliyor?&#10;&#10;`.env.production` dosyasındaki `PUBLIC_BASE_URL` + `/endpoint`&#10;&#10;```&#10;PUBLIC_BASE_URL=https://telegram-ts-bot-backend.karatatar.com&#10;                         ↓&#10;Webhook URL: https://telegram-ts-bot-backend.karatatar.com/endpoint&#10;```&#10;&#10;### Secret nerede kullanılacak?&#10;&#10;İki yerde:&#10;1. `.env.production` dosyasında: `WEBHOOK_SECRET=xxx`&#10;2. RemnaWave panelinde: Secret alanına aynı değer&#10;&#10;İkisi **AYNI** olmalı!&#10;&#10;### Nasıl çalıştığını görebilir miyim?&#10;&#10;Evet! Backend sunucu loglarını izleyin:&#10;&#10;```bash&#10;# Docker kullanıyorsanız&#10;docker logs -f telegram-bot&#10;&#10;# Normal çalıştırıyorsanız&#10;# Terminal'de göreceksiniz&#10;```&#10;&#10;Kullanıcı durumu değiştiğinde şöyle loglar göreceksiniz:&#10;&#10;```&#10;Webhook event received: user.limited&#10;✅ Notification sent to user john_doe (123456789)&#10;```&#10;&#10;### Çalışmazsa?&#10;&#10;1. **Backend çalışıyor mu?** → `curl https://telegram-ts-bot-backend.karatatar.com/health`&#10;2. **Secret doğru mu?** → .env ve panel'de aynı olmalı&#10;3. **URL doğru mu?** → `/webhook/remnawave` sonunda olmalı&#10;4. **SSL var mı?** → HTTPS olmalı (HTTP olmaz)&#10;5. **Logları kontrol et** → Hata mesajlarını göreceksin&#10;&#10;---&#10;&#10;##  Tamamlandı!&#10;&#10;Artık sistem çalışıyor. Kullanıcı trafiği aştığında veya aboneliği bittiğinde otomatik olarak Telegram bildirimi alacak.&#10;&#10;**Test için:** RemnaWave panelinden bir test kullanıcısının trafiğini limite çekin ve webhook'un çalıştığını görün!&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/WEBHOOK_GUIDE.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/WEBHOOK_GUIDE.md" />
              <option name="originalContent" value="# Webhook Entegrasyonu - RemnaWave&#10;&#10;## Genel Bakış&#10;&#10;Webhook kullanarak gerçek zamanlı bildirimler alın. Kullanıcı hesabı kısıtlandığında (trafik aşımı, abonelik bitişi) RemnaWave paneli otomatik olarak webhook'u tetikler ve bot anında kullanıcıya bildirim gönderir.&#10;&#10;## Avantajlar&#10;&#10;✅ **Gerçek Zamanlı** - Olay gerçekleştiğinde hemen bildirim  &#10;✅ **Düşük Kaynak Kullanımı** - Periyodik API kontrolüne gerek yok  &#10;✅ **Güvenli** - HMAC SHA256 imza doğrulama  &#10;✅ **Tek Bildirim** - Her kullanıcıya sadece bir kez mesaj&#10;&#10;## Kurulum&#10;&#10;### 1. Webhook Secret Oluşturun&#10;&#10;Güçlü bir rastgele string oluşturun:&#10;```bash&#10;openssl rand -hex 32&#10;```&#10;&#10;`.env.production` dosyasına ekleyin:&#10;```bash&#10;WEBHOOK_SECRET=your_generated_secret_here&#10;```&#10;&#10;### 2. RemnaWave Panelinde Webhook Ayarlayın&#10;&#10;RemnaWave panel ayarlarına gidin ve webhook ekleyin:&#10;&#10;**Webhook URL:**&#10;```&#10;https://your-domain.com/endpoint&#10;```&#10;&#10;**Secret/Signing Key:**&#10;```&#10;your_generated_secret_here&#10;```&#10;&#10;**NOT:** RemnaWave panelinde event seçimi yoksa, tüm eventleri gönderin.  &#10;Backend otomatik olarak sadece aşağıdaki eventleri işler:&#10;- `user.status.changed`&#10;- `user.disabled`&#10;- `user.limited`&#10;- `user.expired`&#10;&#10;Diğer eventler (user.created, user.updated, vb.) otomatik olarak atlanır.&#10;&#10;### 3. Notifier'ı Kapatın (Opsiyonel)&#10;&#10;Webhook kullanıyorsanız periyodik kontrole gerek yok:&#10;```bash&#10;NOTIFY_INTERVAL_MS=0&#10;```&#10;&#10;## Webhook Event Formatı&#10;&#10;RemnaWave paneli aşağıdaki formatta webhook gönderir:&#10;&#10;```json&#10;{&#10;  &quot;event&quot;: &quot;user.status.changed&quot;,&#10;  &quot;timestamp&quot;: &quot;2024-11-21T10:30:00Z&quot;,&#10;  &quot;data&quot;: {&#10;    &quot;user&quot;: {&#10;      &quot;uuid&quot;: &quot;user-uuid-here&quot;,&#10;      &quot;username&quot;: &quot;john_doe&quot;,&#10;      &quot;status&quot;: &quot;LIMITED&quot;,&#10;      &quot;telegramId&quot;: 123456789,&#10;      &quot;usedTrafficBytes&quot;: 2147483648,&#10;      &quot;trafficLimitBytes&quot;: 2147483648,&#10;      &quot;expireAt&quot;: &quot;2024-12-01T00:00:00Z&quot;&#10;    }&#10;  }&#10;}&#10;```&#10;&#10;## Desteklenen Event Türleri&#10;&#10;| Event | Açıklama | Bildirim Gönderilir mi? |&#10;|-------|----------|-------------------------|&#10;| `user.status.changed` | Kullanıcı durumu değişti | ✅ Evet (LIMITED/EXPIRED/DISABLED ise) |&#10;| `user.disabled` | Kullanıcı devre dışı | ✅ Evet |&#10;| `user.limited` | Trafik kotası doldu | ✅ Evet |&#10;| `user.expired` | Abonelik süresi bitti | ✅ Evet |&#10;| `user.created` | Yeni kullanıcı | ❌ Hayır |&#10;| `user.updated` | Kullanıcı güncellendi | ❌ Hayır |&#10;&#10;## Güvenlik&#10;&#10;### İmza Doğrulama&#10;&#10;Her webhook isteği `x-webhook-signature` header'ı ile gelir:&#10;&#10;```&#10;x-webhook-signature: a1b2c3d4e5f6...&#10;```&#10;&#10;Sistem otomatik olarak HMAC SHA256 ile imzayı doğrular:&#10;&#10;```typescript&#10;const crypto = require('crypto');&#10;const hmac = crypto.createHmac('sha256', WEBHOOK_SECRET);&#10;hmac.update(JSON.stringify(payload));&#10;const expectedSignature = hmac.digest('hex');&#10;&#10;if (receivedSignature === expectedSignature) {&#10;  // Geçerli webhook&#10;}&#10;```&#10;&#10;### IP Whitelist (Opsiyonel)&#10;&#10;RemnaWave panelinin IP adreslerini middleware ile kontrol edebilirsiniz:&#10;&#10;```typescript&#10;const ALLOWED_IPS = ['1.2.3.4', '5.6.7.8'];&#10;&#10;app.use('/webhook/remnawave', (req, res, next) =&gt; {&#10;  const clientIP = req.ip || req.connection.remoteAddress;&#10;  if (!ALLOWED_IPS.includes(clientIP)) {&#10;    return res.status(403).json({ error: 'Forbidden IP' });&#10;  }&#10;  next();&#10;});&#10;```&#10;&#10;## Test&#10;&#10;### Manuel Webhook Testi&#10;&#10;```bash&#10;# Webhook endpoint'ini test edin&#10;curl -X POST &quot;https://your-domain.com/endpoint&quot; \&#10;  -H &quot;Content-Type: application/json&quot; \&#10;  -H &quot;x-webhook-signature: test_signature&quot; \&#10;  -d '{&#10;    &quot;event&quot;: &quot;user.limited&quot;,&#10;    &quot;timestamp&quot;: &quot;2024-11-21T10:30:00Z&quot;,&#10;    &quot;data&quot;: {&#10;      &quot;user&quot;: {&#10;        &quot;uuid&quot;: &quot;test-uuid&quot;,&#10;        &quot;username&quot;: &quot;test_user&quot;,&#10;        &quot;status&quot;: &quot;LIMITED&quot;,&#10;        &quot;telegramId&quot;: 123456789&#10;      }&#10;    }&#10;  }'&#10;```&#10;&#10;### Başarılı Yanıt&#10;&#10;```json&#10;{&#10;  &quot;received&quot;: true,&#10;  &quot;result&quot;: {&#10;    &quot;ok&quot;: true,&#10;    &quot;event&quot;: &quot;user.limited&quot;&#10;  }&#10;}&#10;```&#10;&#10;### Hata Yanıtları&#10;&#10;**Geçersiz İmza:**&#10;```json&#10;{&#10;  &quot;error&quot;: &quot;Invalid signature&quot;&#10;}&#10;```&#10;&#10;**Telegram ID Yok:**&#10;```json&#10;{&#10;  &quot;received&quot;: true,&#10;  &quot;result&quot;: {&#10;    &quot;ok&quot;: false,&#10;    &quot;reason&quot;: &quot;no_telegram_id&quot;&#10;  }&#10;}&#10;```&#10;&#10;**Daha Önce Bildirilmiş:**&#10;```json&#10;{&#10;  &quot;received&quot;: true,&#10;  &quot;result&quot;: {&#10;    &quot;ok&quot;: false,&#10;    &quot;reason&quot;: &quot;already_notified&quot;&#10;  }&#10;}&#10;```&#10;&#10;## Monitoring&#10;&#10;### Webhook Logları&#10;&#10;Sistem otomatik olarak webhook olaylarını loglar:&#10;&#10;```&#10;✅ Webhook event received: user.limited&#10;✅ Notification sent to user test_user (123456789)&#10;⚠️  User test_user has no telegramId, skipping notification&#10;❌ Webhook error: Invalid signature&#10;```&#10;&#10;### Health Check&#10;&#10;Webhook endpoint'inin çalıştığını kontrol edin:&#10;&#10;```bash&#10;curl https://your-domain.com/health&#10;```&#10;&#10;## Sorun Giderme&#10;&#10;### Webhook Gelmiyor&#10;&#10;1. RemnaWave panel webhook ayarlarını kontrol edin&#10;2. URL'nin doğru olduğundan emin olun (https://...)&#10;3. Firewall/güvenlik duvarı ayarlarını kontrol edin&#10;4. Server loglarını inceleyin&#10;&#10;### &quot;Invalid signature&quot; Hatası&#10;&#10;1. `.env.production` dosyasındaki `WEBHOOK_SECRET` değerini kontrol edin&#10;2. RemnaWave panelindeki secret ile aynı olmalı&#10;3. Boşluk veya özel karakter hatası olabilir&#10;&#10;### Bildirim Gönderilmiyor&#10;&#10;1. Kullanıcının `telegramId` alanının dolu olduğundan emin olun&#10;2. Kullanıcı botu engellemiş olabilir&#10;3. Kullanıcıya daha önce bildirim gönderilmiş olabilir (tek seferlik)&#10;4. Event türünün desteklenen listede olduğunu kontrol edin&#10;&#10;### Webhook Çok Geliyor&#10;&#10;RemnaWave panelinde sadece gerekli event'leri seçin:&#10;- ✅ `user.status.changed`&#10;- ✅ `user.limited`&#10;- ✅ `user.expired`&#10;- ✅ `user.disabled`&#10;- ❌ `user.created` (gereksiz)&#10;- ❌ `user.updated` (gereksiz)&#10;&#10;## Performans&#10;&#10;### Gerçek Zamanlı Bildirimler&#10;&#10;| Özellik | Değer |&#10;|---------|-------|&#10;| Gecikme | &lt;1 saniye |&#10;| CPU Kullanımı | Minimal |&#10;| API İstekleri | 0 (sadece webhook) |&#10;| Gerçek Zamanlı | ✅ Evet |&#10;| Kurulum | Orta |&#10;&#10;**Avantaj:** Webhook kullanarak gerçek zamanlı, düşük kaynak kullanımlı bildirimler alırsınız.&#10;&#10;## İleri Seviye&#10;&#10;### Webhook Retry Mekanizması&#10;&#10;RemnaWave webhook başarısız olursa otomatik retry yapar. Eğer kendi retry mekanizmanızı eklemek isterseniz:&#10;&#10;```typescript&#10;// webhook.ts içine ekleyin&#10;const MAX_RETRIES = 3;&#10;const RETRY_DELAY_MS = 5000;&#10;&#10;async function handleWebhookWithRetry(bot: Bot, event: WebhookEvent, retryCount = 0) {&#10;  try {&#10;    return await handleWebhook(bot, event);&#10;  } catch (e) {&#10;    if (retryCount &lt; MAX_RETRIES) {&#10;      await new Promise(resolve =&gt; setTimeout(resolve, RETRY_DELAY_MS));&#10;      return handleWebhookWithRetry(bot, event, retryCount + 1);&#10;    }&#10;    throw e;&#10;  }&#10;}&#10;```&#10;&#10;### Webhook Event Kuyruğu&#10;&#10;Yüksek trafik için Redis/RabbitMQ kullanabilirsiniz:&#10;&#10;```typescript&#10;import Queue from 'bull';&#10;&#10;const webhookQueue = new Queue('webhooks', process.env.REDIS_URL);&#10;&#10;webhookQueue.process(async (job) =&gt; {&#10;  const { bot, event } = job.data;&#10;  return handleWebhook(bot, event);&#10;});&#10;&#10;// Webhook endpoint'inde&#10;app.post('/webhook/remnawave', async (req, res) =&gt; {&#10;  // ... doğrulama ...&#10;  await webhookQueue.add({ bot, event: req.body });&#10;  res.json({ received: true, queued: true });&#10;});&#10;```&#10;&#10;## Örnek Senaryo&#10;&#10;1. Kullanıcı John'un trafiği 2GB limitini aşar&#10;2. RemnaWave paneli durumu `ACTIVE` → `LIMITED` değiştirir&#10;3. Panel webhook gönderir: `user.status.changed`&#10;4. Backend webhook'u alır ve imzayı doğrular&#10;5. John'un Telegram ID'si bulunur&#10;6. Bot John'a bildirim gönderir: &quot;⚠️ Hesabınız kısıtlandı! Trafik kotanız doldu.&quot;&#10;7. John &quot;Hesap Bilgilerim&quot; butonuna tıklar&#10;8. Hesap detayları gösterilir&#10;9. Sistem John'u işaretler (bir daha bildirim gönderilmez)&#10;&#10;**Toplam süre:** &lt;2 saniye (gerçek zamanlı!)&#10;&#10;## Destek&#10;&#10;Sorun yaşarsanız:&#10;1. Server loglarını kontrol edin&#10;2. RemnaWave webhook loglarını kontrol edin&#10;3. Test endpoint'i ile manuel test yapın&#10;4. Dokümantasyonu okuyun: https://docs.rw/docs/features/webhooks&#10;&#10;" />
              <option name="updatedContent" value="# Webhook Entegrasyonu - RemnaWave&#10;&#10;## Genel Bakış&#10;&#10;Webhook kullanarak gerçek zamanlı bildirimler alın. Kullanıcı hesabı kısıtlandığında (trafik aşımı, abonelik bitişi) RemnaWave paneli otomatik olarak webhook'u tetikler ve bot anında kullanıcıya bildirim gönderir.&#10;&#10;## Avantajlar&#10;&#10;✅ **Gerçek Zamanlı** - Olay gerçekleştiğinde hemen bildirim  &#10;✅ **Düşük Kaynak Kullanımı** - Periyodik API kontrolüne gerek yok  &#10;✅ **Güvenli** - HMAC SHA256 imza doğrulama  &#10;✅ **Tek Bildirim** - Her kullanıcıya sadece bir kez mesaj&#10;&#10;## Kurulum&#10;&#10;### 1. Webhook Secret Oluşturun&#10;&#10;Güçlü bir rastgele string oluşturun:&#10;```bash&#10;openssl rand -hex 32&#10;```&#10;&#10;`.env.production` dosyasına ekleyin:&#10;```bash&#10;WEBHOOK_SECRET=your_generated_secret_here&#10;```&#10;&#10;### 2. RemnaWave Panelinde Webhook Ayarlayın&#10;&#10;RemnaWave panel ayarlarına gidin ve webhook ekleyin:&#10;&#10;**Webhook URL:**&#10;```&#10;https://your-domain.com/endpoint&#10;```&#10;&#10;**Secret/Signing Key:**&#10;```&#10;your_generated_secret_here&#10;```&#10;&#10;**NOT:** RemnaWave panelinde event seçimi yoksa, tüm eventleri gönderin.  &#10;Backend otomatik olarak sadece aşağıdaki eventleri işler:&#10;- `user.status.changed`&#10;- `user.disabled`&#10;- `user.limited`&#10;- `user.expired`&#10;&#10;Diğer eventler (user.created, user.updated, vb.) otomatik olarak atlanır.&#10;&#10;### 3. Notifier'ı Kapatın (Opsiyonel)&#10;&#10;Webhook kullanıyorsanız periyodik kontrole gerek yok:&#10;```bash&#10;NOTIFY_INTERVAL_MS=0&#10;```&#10;&#10;## Webhook Event Formatı&#10;&#10;RemnaWave paneli aşağıdaki formatta webhook gönderir:&#10;&#10;```json&#10;{&#10;  &quot;event&quot;: &quot;user.status.changed&quot;,&#10;  &quot;timestamp&quot;: &quot;2024-11-21T10:30:00Z&quot;,&#10;  &quot;data&quot;: {&#10;    &quot;user&quot;: {&#10;      &quot;uuid&quot;: &quot;user-uuid-here&quot;,&#10;      &quot;username&quot;: &quot;john_doe&quot;,&#10;      &quot;status&quot;: &quot;LIMITED&quot;,&#10;      &quot;telegramId&quot;: 123456789,&#10;      &quot;usedTrafficBytes&quot;: 2147483648,&#10;      &quot;trafficLimitBytes&quot;: 2147483648,&#10;      &quot;expireAt&quot;: &quot;2024-12-01T00:00:00Z&quot;&#10;    }&#10;  }&#10;}&#10;```&#10;&#10;## Desteklenen Event Türleri&#10;&#10;| Event | Açıklama | Bildirim Gönderilir mi? |&#10;|-------|----------|-------------------------|&#10;| `user.status.changed` | Kullanıcı durumu değişti | ✅ Evet (LIMITED/EXPIRED/DISABLED ise) |&#10;| `user.disabled` | Kullanıcı devre dışı | ✅ Evet |&#10;| `user.limited` | Trafik kotası doldu | ✅ Evet |&#10;| `user.expired` | Abonelik süresi bitti | ✅ Evet |&#10;| `user.created` | Yeni kullanıcı | ❌ Hayır |&#10;| `user.updated` | Kullanıcı güncellendi | ❌ Hayır |&#10;&#10;## Güvenlik&#10;&#10;### İmza Doğrulama&#10;&#10;Her webhook isteği `x-webhook-signature` header'ı ile gelir:&#10;&#10;```&#10;x-webhook-signature: a1b2c3d4e5f6...&#10;```&#10;&#10;Sistem otomatik olarak HMAC SHA256 ile imzayı doğrular:&#10;&#10;```typescript&#10;const crypto = require('crypto');&#10;const hmac = crypto.createHmac('sha256', WEBHOOK_SECRET);&#10;hmac.update(JSON.stringify(payload));&#10;const expectedSignature = hmac.digest('hex');&#10;&#10;if (receivedSignature === expectedSignature) {&#10;  // Geçerli webhook&#10;}&#10;```&#10;&#10;### IP Whitelist (Opsiyonel)&#10;&#10;RemnaWave panelinin IP adreslerini middleware ile kontrol edebilirsiniz:&#10;&#10;```typescript&#10;const ALLOWED_IPS = ['1.2.3.4', '5.6.7.8'];&#10;&#10;app.use('/webhook/remnawave', (req, res, next) =&gt; {&#10;  const clientIP = req.ip || req.connection.remoteAddress;&#10;  if (!ALLOWED_IPS.includes(clientIP)) {&#10;    return res.status(403).json({ error: 'Forbidden IP' });&#10;  }&#10;  next();&#10;});&#10;```&#10;&#10;## Test&#10;&#10;### Manuel Webhook Testi&#10;&#10;```bash&#10;# Webhook endpoint'ini test edin&#10;curl -X POST &quot;https://your-domain.com/endpoint&quot; \&#10;  -H &quot;Content-Type: application/json&quot; \&#10;  -H &quot;x-webhook-signature: test_signature&quot; \&#10;  -d '{&#10;    &quot;event&quot;: &quot;user.limited&quot;,&#10;    &quot;timestamp&quot;: &quot;2024-11-21T10:30:00Z&quot;,&#10;    &quot;data&quot;: {&#10;      &quot;user&quot;: {&#10;        &quot;uuid&quot;: &quot;test-uuid&quot;,&#10;        &quot;username&quot;: &quot;test_user&quot;,&#10;        &quot;status&quot;: &quot;LIMITED&quot;,&#10;        &quot;telegramId&quot;: 123456789&#10;      }&#10;    }&#10;  }'&#10;```&#10;&#10;### Başarılı Yanıt&#10;&#10;```json&#10;{&#10;  &quot;received&quot;: true,&#10;  &quot;result&quot;: {&#10;    &quot;ok&quot;: true,&#10;    &quot;event&quot;: &quot;user.limited&quot;&#10;  }&#10;}&#10;```&#10;&#10;### Hata Yanıtları&#10;&#10;**Geçersiz İmza:**&#10;```json&#10;{&#10;  &quot;error&quot;: &quot;Invalid signature&quot;&#10;}&#10;```&#10;&#10;**Telegram ID Yok:**&#10;```json&#10;{&#10;  &quot;received&quot;: true,&#10;  &quot;result&quot;: {&#10;    &quot;ok&quot;: false,&#10;    &quot;reason&quot;: &quot;no_telegram_id&quot;&#10;  }&#10;}&#10;```&#10;&#10;**Daha Önce Bildirilmiş:**&#10;```json&#10;{&#10;  &quot;received&quot;: true,&#10;  &quot;result&quot;: {&#10;    &quot;ok&quot;: false,&#10;    &quot;reason&quot;: &quot;already_notified&quot;&#10;  }&#10;}&#10;```&#10;&#10;## Monitoring&#10;&#10;### Webhook Logları&#10;&#10;Sistem otomatik olarak webhook olaylarını loglar:&#10;&#10;```&#10;✅ Webhook event received: user.limited&#10;✅ Notification sent to user test_user (123456789)&#10;⚠️  User test_user has no telegramId, skipping notification&#10;❌ Webhook error: Invalid signature&#10;```&#10;&#10;### Health Check&#10;&#10;Webhook endpoint'inin çalıştığını kontrol edin:&#10;&#10;```bash&#10;curl https://your-domain.com/health&#10;```&#10;&#10;## Sorun Giderme&#10;&#10;### Webhook Gelmiyor&#10;&#10;1. RemnaWave panel webhook ayarlarını kontrol edin&#10;2. URL'nin doğru olduğundan emin olun (https://...)&#10;3. Firewall/güvenlik duvarı ayarlarını kontrol edin&#10;4. Server loglarını inceleyin&#10;&#10;### &quot;Invalid signature&quot; Hatası&#10;&#10;1. `.env.production` dosyasındaki `WEBHOOK_SECRET` değerini kontrol edin&#10;2. RemnaWave panelindeki secret ile aynı olmalı&#10;3. Boşluk veya özel karakter hatası olabilir&#10;&#10;### Bildirim Gönderilmiyor&#10;&#10;1. Kullanıcının `telegramId` alanının dolu olduğundan emin olun&#10;2. Kullanıcı botu engellemiş olabilir&#10;3. Kullanıcıya daha önce bildirim gönderilmiş olabilir (tek seferlik)&#10;### Event türünün desteklenen listede olduğunu kontrol edin&#10;&#10;Backend sadece şu eventleri işler:&#10;- `user.status.changed`&#10;- `user.limited`&#10;- `user.expired`&#10;- `user.disabled`&#10;&#10;Diğer eventler (user.created, user.updated, vb.) otomatik atlanır ve bildirim gönderilmez.&#10;&#10;### Kullanıcı durumunu kontrol edin&#10;&#10;Bildirim sadece kullanıcı kısıtlı durumdaysa gönderilir:&#10;- `status === 'LIMITED'`&#10;- `status === 'EXPIRED'`&#10;- `status === 'DISABLED'`&#10;&#10;Eğer `status === 'ACTIVE'` ise bildirim gönderilmez.&#10;&#10;## Loglar&#10;&#10;### Gerçek Zamanlı Bildirimler&#10;&#10;| Özellik | Değer |&#10;|---------|-------|&#10;| Gecikme | &lt;1 saniye |&#10;| CPU Kullanımı | Minimal |&#10;| API İstekleri | 0 (sadece webhook) |&#10;| Gerçek Zamanlı | ✅ Evet |&#10;| Kurulum | Orta |&#10;&#10;**Avantaj:** Webhook kullanarak gerçek zamanlı, düşük kaynak kullanımlı bildirimler alırsınız.&#10;&#10;## İleri Seviye&#10;&#10;### Webhook Retry Mekanizması&#10;&#10;RemnaWave webhook başarısız olursa otomatik retry yapar. Eğer kendi retry mekanizmanızı eklemek isterseniz:&#10;&#10;```typescript&#10;// webhook.ts içine ekleyin&#10;const MAX_RETRIES = 3;&#10;const RETRY_DELAY_MS = 5000;&#10;&#10;async function handleWebhookWithRetry(bot: Bot, event: WebhookEvent, retryCount = 0) {&#10;  try {&#10;    return await handleWebhook(bot, event);&#10;  } catch (e) {&#10;    if (retryCount &lt; MAX_RETRIES) {&#10;      await new Promise(resolve =&gt; setTimeout(resolve, RETRY_DELAY_MS));&#10;      return handleWebhookWithRetry(bot, event, retryCount + 1);&#10;    }&#10;    throw e;&#10;  }&#10;}&#10;```&#10;&#10;### Webhook Event Kuyruğu&#10;&#10;Yüksek trafik için Redis/RabbitMQ kullanabilirsiniz:&#10;&#10;```typescript&#10;import Queue from 'bull';&#10;&#10;const webhookQueue = new Queue('webhooks', process.env.REDIS_URL);&#10;&#10;webhookQueue.process(async (job) =&gt; {&#10;  const { bot, event } = job.data;&#10;  return handleWebhook(bot, event);&#10;});&#10;&#10;// Webhook endpoint'inde&#10;app.post('/webhook/remnawave', async (req, res) =&gt; {&#10;  // ... doğrulama ...&#10;  await webhookQueue.add({ bot, event: req.body });&#10;  res.json({ received: true, queued: true });&#10;});&#10;```&#10;&#10;## Örnek Senaryo&#10;&#10;1. Kullanıcı John'un trafiği 2GB limitini aşar&#10;2. RemnaWave paneli durumu `ACTIVE` → `LIMITED` değiştirir&#10;3. Panel webhook gönderir: `user.status.changed`&#10;4. Backend webhook'u alır ve imzayı doğrular&#10;5. John'un Telegram ID'si bulunur&#10;6. Bot John'a bildirim gönderir: &quot;⚠️ Hesabınız kısıtlandı! Trafik kotanız doldu.&quot;&#10;7. John &quot;Hesap Bilgilerim&quot; butonuna tıklar&#10;8. Hesap detayları gösterilir&#10;9. Sistem John'u işaretler (bir daha bildirim gönderilmez)&#10;&#10;**Toplam süre:** &lt;2 saniye (gerçek zamanlı!)&#10;&#10;## Destek&#10;&#10;Sorun yaşarsanız:&#10;1. Server loglarını kontrol edin&#10;2. RemnaWave webhook loglarını kontrol edin&#10;3. Test endpoint'i ile manuel test yapın&#10;4. Dokümantasyonu okuyun: https://docs.rw/docs/features/webhooks&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/src/index.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/src/index.ts" />
              <option name="originalContent" value="import &quot;dotenv/config&quot;;&#10;import { Bot, Context, InlineKeyboard } from &quot;grammy&quot;;&#10;import axios from &quot;axios&quot;;&#10;const YAML = require(&quot;yamljs&quot;);&#10;import path from &quot;path&quot;;&#10;import fs from &quot;fs&quot;;&#10;import { createUser, getUserByTelegramId, getInternalSquads, getUserByUsername, getUserHwidDevices, deleteUserHwidDevice } from &quot;./api&quot;;&#10;import express, { Request, Response, NextFunction } from 'express';&#10;import cors from 'cors';&#10;import crypto from 'crypto';&#10;&#10;// --- EXPRESS API SETUP ---&#10;const app = express();&#10;const port = process.env.PORT || 3000;&#10;&#10;app.use(cors()); // Frontend'den gelen isteklere izin ver&#10;app.use(express.json());&#10;&#10;// Health check endpoint for deployments/load balancers&#10;app.get('/health', (_req: Request, res: Response) =&gt; {&#10;  res.status(200).json({ status: 'ok', uptime: process.uptime() });&#10;});&#10;&#10;// Telegram'dan gelen veriyi doğrulamak için middleware&#10;const verifyTelegramWebAppData = (req: Request, res: Response, next: NextFunction) =&gt; {&#10;  const initData = req.headers['x-telegram-init-data'] as string;&#10;  const botToken = process.env.BOT_TOKEN;&#10;&#10;  if (!initData || !botToken) {&#10;    return res.status(401).json({ error: 'Not authorized.' });&#10;  }&#10;&#10;  const params = new URLSearchParams(initData);&#10;  const hash = params.get('hash');&#10;  params.delete('hash');&#10;&#10;  const dataCheckString = Array.from(params.entries())&#10;    .sort(([a], [b]) =&gt; a.localeCompare(b))&#10;    .map(([key, value]) =&gt; `${key}=${value}`)&#10;    .join('\n');&#10;&#10;  const secretKey = crypto.createHmac('sha256', 'WebAppData').update(botToken).digest();&#10;  const calculatedHash = crypto.createHmac('sha256', secretKey).update(dataCheckString).digest('hex');&#10;&#10;  if (calculatedHash === hash) {&#10;    // Doğrulama başarılı, user verisini req objesine ekle&#10;    const userParam = params.get('user');&#10;    if (userParam) {&#10;      (req as any).telegramUser = JSON.parse(userParam);&#10;    }&#10;    return next();&#10;  }&#10;&#10;  return res.status(403).json({ error: 'Invalid hash.' });&#10;};&#10;&#10;// Mini App için hesap bilgisi endpoint'i&#10;app.get('/api/account', verifyTelegramWebAppData, async (req: Request, res: Response) =&gt; {&#10;  try {&#10;    const telegramUser = (req as any).telegramUser;&#10;&#10;    if (!telegramUser || !telegramUser.id) {&#10;      return res.status(400).json({ error: 'User data not found in Telegram initData' });&#10;    }&#10;&#10;    const telegramId = telegramUser.id;&#10;&#10;    const user = await getUserByTelegramId(telegramId);&#10;&#10;    if (!user) {&#10;      return res.status(404).json({ error: 'User not found' });&#10;    }&#10;&#10;    // Fetch HWID devices for this user&#10;    const hwidData = await getUserHwidDevices(user.uuid);&#10;&#10;    // Attach HWID data to user object&#10;    const userWithHwid = {&#10;      ...user,&#10;      hwid: hwidData,&#10;    };&#10;&#10;    console.log('User object sent to frontend:', userWithHwid); // Frontend'e gönderilen user objesini logla&#10;    res.json(userWithHwid);&#10;  } catch (error: any) {&#10;    console.error('API Error:', error);&#10;    res.status(500).json({ error: 'Internal server error' });&#10;  }&#10;});&#10;&#10;&#10;// --- GRAMMY BOT SETUP ---&#10;export const bot = new Bot&lt;Context&gt;(process.env.BOT_TOKEN || &quot;&quot;);&#10;&#10;// OpenAPI YAML dosyasını yükle&#10;let openApiDocument: any;&#10;const openApiFilePath = &quot;./openapi.yaml&quot;;&#10;&#10;try {&#10;  const yamlContent = fs.readFileSync(openApiFilePath, &quot;utf8&quot;);&#10;  openApiDocument = YAML.parse(yamlContent);&#10;  console.log(&quot;OpenAPI document loaded.&quot;);&#10;} catch (error) {&#10;  console.error(&quot;Error loading OpenAPI document:&quot;, error);&#10;}&#10;&#10;// MINI_APP_URL'i burada al&#10;const miniAppUrl = process.env.MINI_APP_URL || &quot;&quot;;&#10;&#10;// Public base URL (for deeplink redirects). If not provided, derive from incoming request.&#10;const PUBLIC_BASE_URL = process.env.PUBLIC_BASE_URL || &quot;&quot;;&#10;&#10;// Validate configuration against remote API at startup&#10;async function validateConfigAtStartup() {&#10;  const squadUuid = process.env.INTERNAL_SQUAD_UUID;&#10;  if (!squadUuid) {&#10;    console.warn(&quot;INTERNAL_SQUAD_UUID is not set. Trial creation may fail.&quot;);&#10;    return;&#10;  }&#10;  try {&#10;    const squads = await getInternalSquads();&#10;    const found = Array.isArray(squads) &amp;&amp; squads.find((s: any) =&gt; s?.uuid === squadUuid);&#10;    if (!found) {&#10;      const available = Array.isArray(squads) ? squads.map((s: any) =&gt; s?.uuid).filter(Boolean).join(&quot;, &quot;) : &quot;&lt;unavailable&gt;&quot;;&#10;      console.error(`Configured INTERNAL_SQUAD_UUID not found on API: ${squadUuid}. Available squads: ${available}`);&#10;    } else {&#10;      console.log(`Validated internal squad: ${found.name || found.uuid}`);&#10;    }&#10;  } catch (e: any) {&#10;    console.error(&quot;Failed to validate INTERNAL_SQUAD_UUID:&quot;, e?.message || e);&#10;  }&#10;}&#10;&#10;// Başlangıç komutu için klavye oluştur&#10;const startKeyboard = new InlineKeyboard()&#10;  .text(&quot; Try for Free&quot;, &quot;try_free&quot;)&#10;  .text(&quot; Satın Al&quot;, &quot;buy_subscription&quot;)&#10;  .row()&#10;  .text(&quot; Hesabım&quot;, &quot;my_account&quot;)&#10;  .webApp(&quot; Mini App&quot;, miniAppUrl); // Doğrudan webApp butonu kullan&#10;&#10;// /start komutuna yanıt ver&#10;bot.command(&quot;start&quot;, async (ctx) =&gt; {&#10;  const welcomeMessage = `&#10;Hoş geldiniz! Bu bot ile VPN hizmetinize erişebilirsiniz.&#10;&#10;Lütfen aşağıdaki seçeneklerden birini seçin:&#10;`;&#10;  await ctx.reply(welcomeMessage, {&#10;    reply_markup: startKeyboard,&#10;  });&#10;});&#10;&#10;// Basit deeplink redirect sayfası (https -&gt; happ://)&#10;app.get('/redirect', (req: Request, res: Response) =&gt; {&#10;  const to = req.query.to as string | undefined;&#10;  const fallback = (req.query.fallback as string | undefined) || 'https://t.me/';&#10;  if (!to) {&#10;    return res.status(400).send('Missing to parameter');&#10;  }&#10;  const html = `&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt;&lt;title&gt;Açılıyor…&lt;/title&gt;&lt;/head&gt;&lt;body style=&quot;font-family:system-ui;padding:24px;background:#111;color:#eee&quot;&gt;&lt;h2&gt;Uygulamada açılıyor…&lt;/h2&gt;&lt;p&gt;Eğer otomatik açılmazsa &lt;a id=&quot;open&quot;&gt;buraya dokunun&lt;/a&gt;.&lt;/p&gt;&lt;script&gt;const to=decodeURIComponent(${JSON.stringify(encodeURIComponent(to))});const fb=decodeURIComponent(${JSON.stringify(encodeURIComponent(fallback))});function open(){window.location.href=to;}document.getElementById('open').setAttribute('href',to);open();setTimeout(()=&gt;{if(document.hidden)return;window.location.href=fb;},1500);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;`;&#10;  res.setHeader('Content-Type', 'text/html; charset=utf-8');&#10;  res.send(html);&#10;});&#10;&#10;// Mini App'ten Happ deeplink'i Telegram sohbetine gönderen köprü endpoint&#10;app.post('/api/happ/open', verifyTelegramWebAppData, async (req: Request, res: Response) =&gt; {&#10;  try {&#10;    const telegramUser = (req as any).telegramUser;&#10;    const chatId = telegramUser?.id;&#10;    if (!chatId) {&#10;      return res.status(400).json({ error: 'Telegram user id not found' });&#10;    }&#10;&#10;    const user = await getUserByTelegramId(chatId);&#10;    const link: string | undefined = user?.happ?.cryptoLink;&#10;    if (!link) {&#10;      return res.status(404).json({ error: 'CryptoLink not found for user' });&#10;    }&#10;&#10;    // Redirect URL (https), constructing absolute base URL&#10;    const proto = (req.headers['x-forwarded-proto'] as string) || (PUBLIC_BASE_URL.startsWith('https') ? 'https' : 'http');&#10;    const hostFromHeader = req.headers['x-forwarded-host'] || req.headers.host;&#10;    const base = PUBLIC_BASE_URL || `${proto}://${hostFromHeader}`;&#10;    const iosStore = 'https://apps.apple.com/us/app/happ-proxy-utility/id6504287215';&#10;    const androidStore = 'https://play.google.com/store/apps/details?id=com.happproxy';&#10;    const fallback = iosStore; // tek fallback bırakıyoruz&#10;    const redirectUrl = `${base}/redirect?to=${encodeURIComponent(link)}&amp;fallback=${encodeURIComponent(fallback)}`;&#10;&#10;    const kb = new InlineKeyboard().url(&quot;Happ’ta Aç&quot;, redirectUrl);&#10;    await bot.api.sendMessage(chatId, &quot;Happ uygulamasında açmak için aşağıdaki butona dokunun:&quot;, { reply_markup: kb });&#10;&#10;    res.json({ ok: true });&#10;  } catch (error: any) {&#10;    console.error('Failed to send Happ deeplink:', error?.message || error);&#10;    res.status(500).json({ error: 'Failed to send deeplink' });&#10;  }&#10;});&#10;&#10;// HWID cihazı silme endpoint&#10;app.delete('/api/hwid/device', verifyTelegramWebAppData, async (req: Request, res: Response) =&gt; {&#10;  try {&#10;    const telegramUser = (req as any).telegramUser;&#10;    const chatId = telegramUser?.id;&#10;    if (!chatId) {&#10;      return res.status(400).json({ error: 'Telegram user id not found' });&#10;    }&#10;&#10;    const { hwid } = req.body;&#10;    if (!hwid) {&#10;      return res.status(400).json({ error: 'HWID parameter is required' });&#10;    }&#10;&#10;    const user = await getUserByTelegramId(chatId);&#10;    if (!user || !user.uuid) {&#10;      return res.status(404).json({ error: 'User not found' });&#10;    }&#10;&#10;    await deleteUserHwidDevice(user.uuid, hwid);&#10;    res.json({ ok: true, message: 'Cihaz başarıyla silindi' });&#10;  } catch (error: any) {&#10;    console.error('Failed to delete HWID device:', error?.message || error);&#10;    res.status(500).json({ error: error?.message || 'Cihaz silinemedi' });&#10;  }&#10;});&#10;&#10;// Mini App'i açacak komut&#10;bot.command(&quot;app&quot;, async (ctx) =&gt; {&#10;  const miniAppUrl = process.env.MINI_APP_URL;&#10;  if (!miniAppUrl) {&#10;    return ctx.reply(&quot;Mini App URL'i ayarlanmamış. Lütfen yöneticinizle iletişime geçin.&quot;);&#10;  }&#10;  await ctx.reply(&quot;Aşağıdaki düğmeye tıklayarak Mini App'i açabilirsiniz:&quot;, {&#10;    reply_markup: new InlineKeyboard().webApp(&quot; Uygulamayı Aç&quot;, miniAppUrl),&#10;  });&#10;});&#10;&#10;// Mini App'ten gelen verileri dinlemek için daha güvenli bir yöntem&#10;bot.on(&quot;message&quot;, async (ctx) =&gt; {&#10;  // Mesajın bir &quot;web_app_data&quot; içerip içermediğini kontrol et&#10;  if (ctx.message &amp;&amp; &quot;web_app_data&quot; in ctx.message &amp;&amp; ctx.message.web_app_data) {&#10;    try {&#10;      const data = JSON.parse(ctx.message.web_app_data.data);&#10;      if (data.command === 'try_free') {&#10;        await handleTryFree(ctx);&#10;      }&#10;    } catch (error) {&#10;      console.error(&quot;Error processing web_app_data&quot;, error);&#10;    }&#10;  }&#10;});&#10;&#10;bot.command(&quot;help&quot;, (ctx) =&gt; ctx.reply(&quot;Size nasıl yardımcı olabilirim?&quot;));&#10;&#10;// &quot;Try for Free&quot; düğmesine basıldığında (orijinal callback)&#10;bot.callbackQuery(&quot;try_free&quot;, async (ctx) =&gt; {&#10;  await handleTryFree(ctx);&#10;});&#10;&#10;// &quot;Satın Al&quot; düğmesine basıldığında&#10;bot.callbackQuery(&quot;buy_subscription&quot;, async (ctx) =&gt; {&#10;  await ctx.answerCallbackQuery({&#10;    text: &quot;Çok yakında!&quot;,&#10;    show_alert: true,&#10;  });&#10;});&#10;&#10;// &quot;Hesabım&quot; düğmesine basıldığında&#10;bot.callbackQuery(&quot;my_account&quot;, async (ctx) =&gt; {&#10;  const telegramId = ctx.from?.id;&#10;&#10;  if (!telegramId) {&#10;    await ctx.answerCallbackQuery(&quot;Hata!&quot;);&#10;    await ctx.reply(&quot;Telegram ID'niz alınamadı. Lütfen tekrar deneyin.&quot;);&#10;    return;&#10;  }&#10;&#10;  try {&#10;    await ctx.answerCallbackQuery(&quot;Hesap bilgileriniz getiriliyor...&quot;);&#10;&#10;    const user = await getUserByTelegramId(telegramId);&#10;&#10;    if (!user) {&#10;      await ctx.reply(&quot;Sistemde kayıtlı bir hesabınız bulunamadı. Lütfen önce 'Try for Free' seçeneği ile bir deneme hesabı oluşturun.&quot;);&#10;      return;&#10;    }&#10;&#10;    // Satın al butonu&#10;    const buyKeyboard = new InlineKeyboard().text(&quot; Yeni Abonelik Satın Al&quot;, &quot;buy_subscription&quot;);&#10;&#10;    // Eğer hesap limitli veya süresi dolmuşsa, kullanıcıyı bilgilendir ve satın almaya yönlendir&#10;    if (user.status === 'LIMITED' || user.status === 'EXPIRED') {&#10;      let reason = user.status === 'LIMITED' ? &quot;Trafik kotanız doldu.&quot; : &quot;Abonelik süreniz sona erdi.&quot;;&#10;      await ctx.reply(`&#10;⚠️ **Hesabınız Kısıtlandı!**&#10;&#10;${reason}&#10;&#10;Hizmetimizi kullanmaya devam etmek için lütfen yeni bir abonelik satın alın.&#10;      `, { reply_markup: buyKeyboard });&#10;      return;&#10;    }&#10;&#10;    // Kalan süreyi hesapla&#10;    const expireDate = new Date(user.expireAt);&#10;    const now = new Date();&#10;    const diffTime = expireDate.getTime() - now.getTime();&#10;    const diffDays = Math.max(0, Math.ceil(diffTime / (1000 * 60 * 60 * 24)));&#10;&#10;    // Kalan kotayı GB olarak hesapla&#10;    const trafficLimitGB = (user.trafficLimitBytes / (1024 * 1024 * 1024)).toFixed(2);&#10;    const trafficUsedGB = (user.usedTrafficBytes / (1024 * 1024 * 1024)).toFixed(2);&#10;    const trafficLeftGB = (Math.max(0, user.trafficLimitBytes - user.usedTrafficBytes) / (1024 * 1024 * 1024)).toFixed(2);&#10;&#10;    // Durum için emoji ve metin belirle&#10;    let statusText = &quot;&quot;;&#10;    switch (user.status) {&#10;      case 'ACTIVE':&#10;        statusText = &quot; Aktif&quot;;&#10;        break;&#10;      case 'DISABLED':&#10;        statusText = &quot; Pasif&quot;;&#10;        break;&#10;      case 'LIMITED':&#10;        statusText = &quot; Limitli&quot;;&#10;        break;&#10;      case 'EXPIRED':&#10;        statusText = &quot;⚪️ Süresi Doldu&quot;;&#10;        break;&#10;      default:&#10;        statusText = user.status;&#10;    }&#10;&#10;    // HTML'de sorun yaratabilecek karakterleri temizle&#10;    const escapeHTML = (text: string) =&gt; text.replace(/&lt;/g, &quot;&amp;lt;&quot;).replace(/&gt;/g, &quot;&amp;gt;&quot;).replace(/&amp;/g, &quot;&amp;amp;&quot;);&#10;&#10;    const appDownloadKeyboard = new InlineKeyboard()&#10;      .url(&quot; iOS&quot;, &quot;https://apps.apple.com/us/app/happ-proxy-utility/id6504287215&quot;) // Lütfen bu linki güncelleyin&#10;      .url(&quot; Android&quot;, &quot;https://play.google.com/store/apps/details?id=com.happproxy&quot;); // Lütfen bu linki güncelleyin&#10;&#10;    const accountInfo = `&#10;&lt;b&gt; VPN Hesap Detaylarınız &lt;/b&gt;&#10;&#10; &lt;b&gt;Kullanıcı Adı:&lt;/b&gt; &lt;code&gt;${escapeHTML(user.username)}&lt;/code&gt;&#10;*️⃣ &lt;b&gt;Abonelik Türü:&lt;/b&gt; &lt;code&gt;${escapeHTML(user.tag || 'PREMIUM')}&lt;/code&gt;&#10; &lt;b&gt;Bitiş Tarihi:&lt;/b&gt; &lt;code&gt;${expireDate.toLocaleDateString('tr-TR', { day: 'numeric', month: 'long', year: 'numeric' })}&lt;/code&gt;&#10; &lt;b&gt;Kota:&lt;/b&gt; &lt;code&gt;${trafficLeftGB} GB / ${trafficLimitGB} GB&lt;/code&gt;&#10;&#10;&lt;b&gt;Durum:&lt;/b&gt; ${statusText}&#10;&#10;&lt;b&gt;Happ CryptoLink:&lt;/b&gt;&#10;&lt;pre&gt;&lt;code&gt;${escapeHTML(user.happ.cryptoLink)}&lt;/code&gt;&lt;/pre&gt;&#10;&#10;Uygulamanız yoksa aşağıdan indirebilirsiniz &#10;    `;&#10;&#10;    await ctx.reply(accountInfo, { &#10;      parse_mode: &quot;HTML&quot;,&#10;      reply_markup: appDownloadKeyboard &#10;    });&#10;&#10;  } catch (error: any) {&#10;    await ctx.answerCallbackQuery(&quot;Hata!&quot;);&#10;    await ctx.reply(`Hesap bilgileriniz alınırken bir hata oluştu: ${error.message}`);&#10;  }&#10;});&#10;&#10;// &quot;Try for Free&quot; mantığını yeniden kullanılabilir bir fonksiyona taşıyalım&#10;async function handleTryFree(ctx: Context) {&#10;  const telegramId = ctx.from?.id;&#10;  const username = ctx.from?.username;&#10;&#10;  if (!telegramId) {&#10;    await ctx.answerCallbackQuery?.(&quot;Hata!&quot;);&#10;    await ctx.reply(&quot;Telegram ID'niz alınamadı. Lütfen tekrar deneyin.&quot;);&#10;    return;&#10;  }&#10;&#10;  if (!username) {&#10;    await ctx.answerCallbackQuery?.();&#10;    await ctx.reply(&quot;Kayıt olabilmek için bir Telegram kullanıcı adınızın olması gerekmektedir.&quot;);&#10;    return;&#10;  }&#10;&#10;  try {&#10;    // Kullanıcının zaten var olup olmadığını Telegram ID ile kontrol et&#10;    const existingUser = await getUserByTelegramId(telegramId);&#10;    if (existingUser) {&#10;      await ctx.answerCallbackQuery?.();&#10;      await ctx.reply(`Bu Telegram hesabı ile zaten bir kullanıcı mevcut: &lt;code&gt;${existingUser.username}&lt;/code&gt;\n\nHesap durumunuzu kontrol etmek için ana menüdeki &quot;Hesap Durumu&quot; düğmesini kullanabilirsiniz.`, { parse_mode: &quot;HTML&quot; });&#10;      return;&#10;    }&#10;&#10;    await ctx.answerCallbackQuery?.(&quot;Deneme hesabınız oluşturuluyor...&quot;);&#10;&#10;    // Kullanıcı adı çakışmalarını önlemek için benzersiz bir username üret&#10;    let finalUsername = username;&#10;    try {&#10;      const existingByUsername = await getUserByUsername(username);&#10;      if (existingByUsername) {&#10;        const base = username.slice(0, Math.max(0, 30));&#10;        const suffix = `-${Math.floor(1000 + Math.random() * 9000)}`;&#10;        finalUsername = `${base}${suffix}`;&#10;      }&#10;    } catch (e) {&#10;      // username kontrolü başarısızsa sessizce devam et, API zaten doğrulayacaktır&#10;    }&#10;&#10;    const squadUuid = process.env.INTERNAL_SQUAD_UUID;&#10;&#10;    if (!squadUuid) {&#10;      throw new Error(&quot;INTERNAL_SQUAD_UUID environment variable is not set&quot;);&#10;    }&#10;&#10;    // 3 gün sonrası için son kullanma tarihi oluştur&#10;    const expireAt = new Date();&#10;    expireAt.setDate(expireAt.getDate() + 3);&#10;&#10;    const newUser = {&#10;      username: finalUsername,&#10;      telegramId,&#10;      tag: &quot;TRIAL&quot;, // Kullanıcıya TRIAL etiketini ekle&#10;      expireAt: expireAt.toISOString(),&#10;      trafficLimitBytes: 2 * 1024 * 1024 * 1024, // 2 GB&#10;      trafficLimitStrategy: &quot;NO_RESET&quot;,&#10;      activeInternalSquads: [squadUuid],&#10;    };&#10;&#10;    // Username çakışmalarına karşı birkaç kez dene&#10;    let createdUser: any = null;&#10;    const baseName = finalUsername.slice(0, Math.max(0, 30));&#10;    for (let attempt = 0; attempt &lt; 5; attempt++) {&#10;      try {&#10;        createdUser = await createUser(newUser);&#10;        break;&#10;      } catch (err: any) {&#10;        const msg = String(err?.message || &quot;&quot;);&#10;        const looksLikeUsernameConflict = msg.includes(&quot;A018&quot;) || msg.includes(&quot;409&quot;) || msg.toLowerCase().includes(&quot;username&quot;);&#10;        if (!looksLikeUsernameConflict || attempt === 4) {&#10;          throw err;&#10;        }&#10;        const suffix = `-${Math.floor(1000 + Math.random() * 9000)}`;&#10;        finalUsername = `${baseName}${suffix}`;&#10;        newUser.username = finalUsername;&#10;      }&#10;    }&#10;&#10;    const myAccountKeyboard = new InlineKeyboard().text(&quot; Hesabım&quot;, &quot;my_account&quot;);&#10;&#10;    await ctx.reply(` Deneme hesabınız başarıyla oluşturuldu, @${username}!\n\nHesabınız &lt;b&gt;3 gün&lt;/b&gt; geçerlidir ve &lt;b&gt;2 GB&lt;/b&gt; trafik limitiniz bulunmaktadır.\n\nAşağıdaki butona tıklayarak hesap detaylarınızı görebilirsiniz.`, {&#10;      parse_mode: &quot;HTML&quot;,&#10;      reply_markup: myAccountKeyboard,&#10;    });&#10;  } catch (error: any) {&#10;    const telegramIdForCatch = ctx.from?.id;&#10;    const msg = String(error?.message || &quot;&quot;);&#10;    // A018 genellikle sunucuda mevcut hesap/benzersizlik ihlali durumunu ifade eder&#10;    if (msg.includes(&quot;A018&quot;) &amp;&amp; telegramIdForCatch) {&#10;      try {&#10;        const existing = await getUserByTelegramId(telegramIdForCatch);&#10;        if (existing) {&#10;          const myAccountKeyboard = new InlineKeyboard().text(&quot; Hesabım&quot;, &quot;my_account&quot;);&#10;          await ctx.answerCallbackQuery?.();&#10;          await ctx.reply(&quot;Bu Telegram hesabıyla zaten bir kullanıcı mevcut. Hesap detaylarını görüntülemek için aşağıdaki düğmeyi kullanın.&quot;, { reply_markup: myAccountKeyboard });&#10;          return;&#10;        }&#10;      } catch {}&#10;    }&#10;    await ctx.answerCallbackQuery?.(&quot;Hata!&quot;);&#10;    await ctx.reply(`Kullanıcı oluşturulurken bir hata oluştu: ${error.message}`);&#10;  }&#10;}&#10;&#10;// Internal test endpoint: webhook'u manuel test etmek için (PROD: koruma gerektirir)&#10;app.post('/internal/test-webhook/:telegramId', async (req: Request, res: Response) =&gt; {&#10;  const token = req.headers['x-internal-token'] as string | undefined;&#10;  const expected = process.env.INTERNAL_NOTIFY_TOKEN;&#10;  if (!expected || token !== expected) {&#10;    return res.status(403).json({ error: 'Forbidden' });&#10;  }&#10;&#10;  const telegramIdParam = req.params.telegramId;&#10;  const reason = req.body?.reason as string | undefined;&#10;&#10;  try {&#10;    const user = await getUserByTelegramId(Number(telegramIdParam));&#10;    if (!user) {&#10;      return res.status(404).json({ error: 'User not found' });&#10;    }&#10;&#10;    // Webhook event simülasyonu&#10;    const mockEvent = {&#10;      event: 'user.limited',&#10;      timestamp: new Date().toISOString(),&#10;      data: { user }&#10;    };&#10;&#10;    const { handleWebhook } = await import('./webhook');&#10;    const result = await handleWebhook(bot, mockEvent, reason);&#10;    res.json(result);&#10;  } catch (e: any) {&#10;    console.error('Internal test error:', e);&#10;    res.status(500).json({ error: String(e?.message || e) });&#10;  }&#10;});&#10;&#10;// Webhook endpoint: RemnaWave panelinden gelen olayları dinle&#10;app.post('/endpoint', async (req: Request, res: Response) =&gt; {&#10;  try {&#10;    const signature = req.headers['x-webhook-signature'] as string | undefined;&#10;    const webhookSecret = process.env.WEBHOOK_SECRET;&#10;&#10;    // Webhook secret varsa imza doğrula&#10;    if (webhookSecret &amp;&amp; signature) {&#10;      const { verifyWebhookSignature } = await import('./webhook');&#10;      const payload = JSON.stringify(req.body);&#10;      const isValid = verifyWebhookSignature(payload, signature, webhookSecret);&#10;&#10;      if (!isValid) {&#10;        console.warn('Invalid webhook signature');&#10;        return res.status(401).json({ error: 'Invalid signature' });&#10;      }&#10;    }&#10;&#10;    const event = req.body;&#10;    console.log('Webhook event received:', event.event);&#10;&#10;    const { handleWebhook } = await import('./webhook');&#10;    const result = await handleWebhook(bot, event);&#10;&#10;    res.json({ received: true, result });&#10;  } catch (e: any) {&#10;    console.error('Webhook error:', e?.message || e);&#10;    res.status(500).json({ error: 'Internal server error' });&#10;  }&#10;});&#10;&#10;// ...existing code...&#10;&#10;async function startApp() {&#10;  // Start the Express server&#10;  app.listen(port, () =&gt; {&#10;    console.log(`API server listening on port ${port}`);&#10;    console.log(`Webhook endpoint: POST /webhook/remnawave`);&#10;  });&#10;&#10;  // Start the Telegram bot&#10;  await validateConfigAtStartup();&#10;  bot.start();&#10;  console.log(&quot;Bot started!&quot;);&#10;  console.log(&quot;Webhook mode: Real-time notifications enabled ⚡&quot;);&#10;}&#10;&#10;startApp();&#10;" />
              <option name="updatedContent" value="import &quot;dotenv/config&quot;;&#10;import { Bot, Context, InlineKeyboard } from &quot;grammy&quot;;&#10;import axios from &quot;axios&quot;;&#10;const YAML = require(&quot;yamljs&quot;);&#10;import path from &quot;path&quot;;&#10;import fs from &quot;fs&quot;;&#10;import { createUser, getUserByTelegramId, getInternalSquads, getUserByUsername, getUserHwidDevices, deleteUserHwidDevice } from &quot;./api&quot;;&#10;import express, { Request, Response, NextFunction } from 'express';&#10;import cors from 'cors';&#10;import crypto from 'crypto';&#10;&#10;// --- EXPRESS API SETUP ---&#10;const app = express();&#10;const port = process.env.PORT || 3000;&#10;&#10;app.use(cors()); // Frontend'den gelen isteklere izin ver&#10;app.use(express.json());&#10;&#10;// Health check endpoint for deployments/load balancers&#10;app.get('/health', (_req: Request, res: Response) =&gt; {&#10;  res.status(200).json({ status: 'ok', uptime: process.uptime() });&#10;});&#10;&#10;// Telegram'dan gelen veriyi doğrulamak için middleware&#10;const verifyTelegramWebAppData = (req: Request, res: Response, next: NextFunction) =&gt; {&#10;  const initData = req.headers['x-telegram-init-data'] as string;&#10;  const botToken = process.env.BOT_TOKEN;&#10;&#10;  if (!initData || !botToken) {&#10;    return res.status(401).json({ error: 'Not authorized.' });&#10;  }&#10;&#10;  const params = new URLSearchParams(initData);&#10;  const hash = params.get('hash');&#10;  params.delete('hash');&#10;&#10;  const dataCheckString = Array.from(params.entries())&#10;    .sort(([a], [b]) =&gt; a.localeCompare(b))&#10;    .map(([key, value]) =&gt; `${key}=${value}`)&#10;    .join('\n');&#10;&#10;  const secretKey = crypto.createHmac('sha256', 'WebAppData').update(botToken).digest();&#10;  const calculatedHash = crypto.createHmac('sha256', secretKey).update(dataCheckString).digest('hex');&#10;&#10;  if (calculatedHash === hash) {&#10;    // Doğrulama başarılı, user verisini req objesine ekle&#10;    const userParam = params.get('user');&#10;    if (userParam) {&#10;      (req as any).telegramUser = JSON.parse(userParam);&#10;    }&#10;    return next();&#10;  }&#10;&#10;  return res.status(403).json({ error: 'Invalid hash.' });&#10;};&#10;&#10;// Mini App için hesap bilgisi endpoint'i&#10;app.get('/api/account', verifyTelegramWebAppData, async (req: Request, res: Response) =&gt; {&#10;  try {&#10;    const telegramUser = (req as any).telegramUser;&#10;&#10;    if (!telegramUser || !telegramUser.id) {&#10;      return res.status(400).json({ error: 'User data not found in Telegram initData' });&#10;    }&#10;&#10;    const telegramId = telegramUser.id;&#10;&#10;    const user = await getUserByTelegramId(telegramId);&#10;&#10;    if (!user) {&#10;      return res.status(404).json({ error: 'User not found' });&#10;    }&#10;&#10;    // Fetch HWID devices for this user&#10;    const hwidData = await getUserHwidDevices(user.uuid);&#10;&#10;    // Attach HWID data to user object&#10;    const userWithHwid = {&#10;      ...user,&#10;      hwid: hwidData,&#10;    };&#10;&#10;    console.log('User object sent to frontend:', userWithHwid); // Frontend'e gönderilen user objesini logla&#10;    res.json(userWithHwid);&#10;  } catch (error: any) {&#10;    console.error('API Error:', error);&#10;    res.status(500).json({ error: 'Internal server error' });&#10;  }&#10;});&#10;&#10;&#10;// --- GRAMMY BOT SETUP ---&#10;export const bot = new Bot&lt;Context&gt;(process.env.BOT_TOKEN || &quot;&quot;);&#10;&#10;// OpenAPI YAML dosyasını yükle&#10;let openApiDocument: any;&#10;const openApiFilePath = &quot;./openapi.yaml&quot;;&#10;&#10;try {&#10;  const yamlContent = fs.readFileSync(openApiFilePath, &quot;utf8&quot;);&#10;  openApiDocument = YAML.parse(yamlContent);&#10;  console.log(&quot;OpenAPI document loaded.&quot;);&#10;} catch (error) {&#10;  console.error(&quot;Error loading OpenAPI document:&quot;, error);&#10;}&#10;&#10;// MINI_APP_URL'i burada al&#10;const miniAppUrl = process.env.MINI_APP_URL || &quot;&quot;;&#10;&#10;// Public base URL (for deeplink redirects). If not provided, derive from incoming request.&#10;const PUBLIC_BASE_URL = process.env.PUBLIC_BASE_URL || &quot;&quot;;&#10;&#10;// Validate configuration against remote API at startup&#10;async function validateConfigAtStartup() {&#10;  const squadUuid = process.env.INTERNAL_SQUAD_UUID;&#10;  if (!squadUuid) {&#10;    console.warn(&quot;INTERNAL_SQUAD_UUID is not set. Trial creation may fail.&quot;);&#10;    return;&#10;  }&#10;  try {&#10;    const squads = await getInternalSquads();&#10;    const found = Array.isArray(squads) &amp;&amp; squads.find((s: any) =&gt; s?.uuid === squadUuid);&#10;    if (!found) {&#10;      const available = Array.isArray(squads) ? squads.map((s: any) =&gt; s?.uuid).filter(Boolean).join(&quot;, &quot;) : &quot;&lt;unavailable&gt;&quot;;&#10;      console.error(`Configured INTERNAL_SQUAD_UUID not found on API: ${squadUuid}. Available squads: ${available}`);&#10;    } else {&#10;      console.log(`Validated internal squad: ${found.name || found.uuid}`);&#10;    }&#10;  } catch (e: any) {&#10;    console.error(&quot;Failed to validate INTERNAL_SQUAD_UUID:&quot;, e?.message || e);&#10;  }&#10;}&#10;&#10;// Başlangıç komutu için klavye oluştur&#10;const startKeyboard = new InlineKeyboard()&#10;  .text(&quot; Try for Free&quot;, &quot;try_free&quot;)&#10;  .text(&quot; Satın Al&quot;, &quot;buy_subscription&quot;)&#10;  .row()&#10;  .text(&quot; Hesabım&quot;, &quot;my_account&quot;)&#10;  .webApp(&quot; Mini App&quot;, miniAppUrl); // Doğrudan webApp butonu kullan&#10;&#10;// /start komutuna yanıt ver&#10;bot.command(&quot;start&quot;, async (ctx) =&gt; {&#10;  const welcomeMessage = `&#10;Hoş geldiniz! Bu bot ile VPN hizmetinize erişebilirsiniz.&#10;&#10;Lütfen aşağıdaki seçeneklerden birini seçin:&#10;`;&#10;  await ctx.reply(welcomeMessage, {&#10;    reply_markup: startKeyboard,&#10;  });&#10;});&#10;&#10;// Basit deeplink redirect sayfası (https -&gt; happ://)&#10;app.get('/redirect', (req: Request, res: Response) =&gt; {&#10;  const to = req.query.to as string | undefined;&#10;  const fallback = (req.query.fallback as string | undefined) || 'https://t.me/';&#10;  if (!to) {&#10;    return res.status(400).send('Missing to parameter');&#10;  }&#10;  const html = `&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt;&lt;title&gt;Açılıyor…&lt;/title&gt;&lt;/head&gt;&lt;body style=&quot;font-family:system-ui;padding:24px;background:#111;color:#eee&quot;&gt;&lt;h2&gt;Uygulamada açılıyor…&lt;/h2&gt;&lt;p&gt;Eğer otomatik açılmazsa &lt;a id=&quot;open&quot;&gt;buraya dokunun&lt;/a&gt;.&lt;/p&gt;&lt;script&gt;const to=decodeURIComponent(${JSON.stringify(encodeURIComponent(to))});const fb=decodeURIComponent(${JSON.stringify(encodeURIComponent(fallback))});function open(){window.location.href=to;}document.getElementById('open').setAttribute('href',to);open();setTimeout(()=&gt;{if(document.hidden)return;window.location.href=fb;},1500);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;`;&#10;  res.setHeader('Content-Type', 'text/html; charset=utf-8');&#10;  res.send(html);&#10;});&#10;&#10;// Mini App'ten Happ deeplink'i Telegram sohbetine gönderen köprü endpoint&#10;app.post('/api/happ/open', verifyTelegramWebAppData, async (req: Request, res: Response) =&gt; {&#10;  try {&#10;    const telegramUser = (req as any).telegramUser;&#10;    const chatId = telegramUser?.id;&#10;    if (!chatId) {&#10;      return res.status(400).json({ error: 'Telegram user id not found' });&#10;    }&#10;&#10;    const user = await getUserByTelegramId(chatId);&#10;    const link: string | undefined = user?.happ?.cryptoLink;&#10;    if (!link) {&#10;      return res.status(404).json({ error: 'CryptoLink not found for user' });&#10;    }&#10;&#10;    // Redirect URL (https), constructing absolute base URL&#10;    const proto = (req.headers['x-forwarded-proto'] as string) || (PUBLIC_BASE_URL.startsWith('https') ? 'https' : 'http');&#10;    const hostFromHeader = req.headers['x-forwarded-host'] || req.headers.host;&#10;    const base = PUBLIC_BASE_URL || `${proto}://${hostFromHeader}`;&#10;    const iosStore = 'https://apps.apple.com/us/app/happ-proxy-utility/id6504287215';&#10;    const androidStore = 'https://play.google.com/store/apps/details?id=com.happproxy';&#10;    const fallback = iosStore; // tek fallback bırakıyoruz&#10;    const redirectUrl = `${base}/redirect?to=${encodeURIComponent(link)}&amp;fallback=${encodeURIComponent(fallback)}`;&#10;&#10;    const kb = new InlineKeyboard().url(&quot;Happ’ta Aç&quot;, redirectUrl);&#10;    await bot.api.sendMessage(chatId, &quot;Happ uygulamasında açmak için aşağıdaki butona dokunun:&quot;, { reply_markup: kb });&#10;&#10;    res.json({ ok: true });&#10;  } catch (error: any) {&#10;    console.error('Failed to send Happ deeplink:', error?.message || error);&#10;    res.status(500).json({ error: 'Failed to send deeplink' });&#10;  }&#10;});&#10;&#10;// HWID cihazı silme endpoint&#10;app.delete('/api/hwid/device', verifyTelegramWebAppData, async (req: Request, res: Response) =&gt; {&#10;  try {&#10;    const telegramUser = (req as any).telegramUser;&#10;    const chatId = telegramUser?.id;&#10;    if (!chatId) {&#10;      return res.status(400).json({ error: 'Telegram user id not found' });&#10;    }&#10;&#10;    const { hwid } = req.body;&#10;    if (!hwid) {&#10;      return res.status(400).json({ error: 'HWID parameter is required' });&#10;    }&#10;&#10;    const user = await getUserByTelegramId(chatId);&#10;    if (!user || !user.uuid) {&#10;      return res.status(404).json({ error: 'User not found' });&#10;    }&#10;&#10;    await deleteUserHwidDevice(user.uuid, hwid);&#10;    res.json({ ok: true, message: 'Cihaz başarıyla silindi' });&#10;  } catch (error: any) {&#10;    console.error('Failed to delete HWID device:', error?.message || error);&#10;    res.status(500).json({ error: error?.message || 'Cihaz silinemedi' });&#10;  }&#10;});&#10;&#10;// Mini App'i açacak komut&#10;bot.command(&quot;app&quot;, async (ctx) =&gt; {&#10;  const miniAppUrl = process.env.MINI_APP_URL;&#10;  if (!miniAppUrl) {&#10;    return ctx.reply(&quot;Mini App URL'i ayarlanmamış. Lütfen yöneticinizle iletişime geçin.&quot;);&#10;  }&#10;  await ctx.reply(&quot;Aşağıdaki düğmeye tıklayarak Mini App'i açabilirsiniz:&quot;, {&#10;    reply_markup: new InlineKeyboard().webApp(&quot; Uygulamayı Aç&quot;, miniAppUrl),&#10;  });&#10;});&#10;&#10;// Mini App'ten gelen verileri dinlemek için daha güvenli bir yöntem&#10;bot.on(&quot;message&quot;, async (ctx) =&gt; {&#10;  // Mesajın bir &quot;web_app_data&quot; içerip içermediğini kontrol et&#10;  if (ctx.message &amp;&amp; &quot;web_app_data&quot; in ctx.message &amp;&amp; ctx.message.web_app_data) {&#10;    try {&#10;      const data = JSON.parse(ctx.message.web_app_data.data);&#10;      if (data.command === 'try_free') {&#10;        await handleTryFree(ctx);&#10;      }&#10;    } catch (error) {&#10;      console.error(&quot;Error processing web_app_data&quot;, error);&#10;    }&#10;  }&#10;});&#10;&#10;bot.command(&quot;help&quot;, (ctx) =&gt; ctx.reply(&quot;Size nasıl yardımcı olabilirim?&quot;));&#10;&#10;// &quot;Try for Free&quot; düğmesine basıldığında (orijinal callback)&#10;bot.callbackQuery(&quot;try_free&quot;, async (ctx) =&gt; {&#10;  await handleTryFree(ctx);&#10;});&#10;&#10;// &quot;Satın Al&quot; düğmesine basıldığında&#10;bot.callbackQuery(&quot;buy_subscription&quot;, async (ctx) =&gt; {&#10;  await ctx.answerCallbackQuery({&#10;    text: &quot;Çok yakında!&quot;,&#10;    show_alert: true,&#10;  });&#10;});&#10;&#10;// &quot;Hesabım&quot; düğmesine basıldığında&#10;bot.callbackQuery(&quot;my_account&quot;, async (ctx) =&gt; {&#10;  const telegramId = ctx.from?.id;&#10;&#10;  if (!telegramId) {&#10;    await ctx.answerCallbackQuery(&quot;Hata!&quot;);&#10;    await ctx.reply(&quot;Telegram ID'niz alınamadı. Lütfen tekrar deneyin.&quot;);&#10;    return;&#10;  }&#10;&#10;  try {&#10;    await ctx.answerCallbackQuery(&quot;Hesap bilgileriniz getiriliyor...&quot;);&#10;&#10;    const user = await getUserByTelegramId(telegramId);&#10;&#10;    if (!user) {&#10;      await ctx.reply(&quot;Sistemde kayıtlı bir hesabınız bulunamadı. Lütfen önce 'Try for Free' seçeneği ile bir deneme hesabı oluşturun.&quot;);&#10;      return;&#10;    }&#10;&#10;    // Satın al butonu&#10;    const buyKeyboard = new InlineKeyboard().text(&quot; Yeni Abonelik Satın Al&quot;, &quot;buy_subscription&quot;);&#10;&#10;    // Eğer hesap limitli veya süresi dolmuşsa, kullanıcıyı bilgilendir ve satın almaya yönlendir&#10;    if (user.status === 'LIMITED' || user.status === 'EXPIRED') {&#10;      let reason = user.status === 'LIMITED' ? &quot;Trafik kotanız doldu.&quot; : &quot;Abonelik süreniz sona erdi.&quot;;&#10;      await ctx.reply(`&#10;⚠️ **Hesabınız Kısıtlandı!**&#10;&#10;${reason}&#10;&#10;Hizmetimizi kullanmaya devam etmek için lütfen yeni bir abonelik satın alın.&#10;      `, { reply_markup: buyKeyboard });&#10;      return;&#10;    }&#10;&#10;    // Kalan süreyi hesapla&#10;    const expireDate = new Date(user.expireAt);&#10;    const now = new Date();&#10;    const diffTime = expireDate.getTime() - now.getTime();&#10;    const diffDays = Math.max(0, Math.ceil(diffTime / (1000 * 60 * 60 * 24)));&#10;&#10;    // Kalan kotayı GB olarak hesapla&#10;    const trafficLimitGB = (user.trafficLimitBytes / (1024 * 1024 * 1024)).toFixed(2);&#10;    const trafficUsedGB = (user.usedTrafficBytes / (1024 * 1024 * 1024)).toFixed(2);&#10;    const trafficLeftGB = (Math.max(0, user.trafficLimitBytes - user.usedTrafficBytes) / (1024 * 1024 * 1024)).toFixed(2);&#10;&#10;    // Durum için emoji ve metin belirle&#10;    let statusText = &quot;&quot;;&#10;    switch (user.status) {&#10;      case 'ACTIVE':&#10;        statusText = &quot; Aktif&quot;;&#10;        break;&#10;      case 'DISABLED':&#10;        statusText = &quot; Pasif&quot;;&#10;        break;&#10;      case 'LIMITED':&#10;        statusText = &quot; Limitli&quot;;&#10;        break;&#10;      case 'EXPIRED':&#10;        statusText = &quot;⚪️ Süresi Doldu&quot;;&#10;        break;&#10;      default:&#10;        statusText = user.status;&#10;    }&#10;&#10;    // HTML'de sorun yaratabilecek karakterleri temizle&#10;    const escapeHTML = (text: string) =&gt; text.replace(/&lt;/g, &quot;&amp;lt;&quot;).replace(/&gt;/g, &quot;&amp;gt;&quot;).replace(/&amp;/g, &quot;&amp;amp;&quot;);&#10;&#10;    const appDownloadKeyboard = new InlineKeyboard()&#10;      .url(&quot; iOS&quot;, &quot;https://apps.apple.com/us/app/happ-proxy-utility/id6504287215&quot;) // Lütfen bu linki güncelleyin&#10;      .url(&quot; Android&quot;, &quot;https://play.google.com/store/apps/details?id=com.happproxy&quot;); // Lütfen bu linki güncelleyin&#10;&#10;    const accountInfo = `&#10;&lt;b&gt; VPN Hesap Detaylarınız &lt;/b&gt;&#10;&#10; &lt;b&gt;Kullanıcı Adı:&lt;/b&gt; &lt;code&gt;${escapeHTML(user.username)}&lt;/code&gt;&#10;*️⃣ &lt;b&gt;Abonelik Türü:&lt;/b&gt; &lt;code&gt;${escapeHTML(user.tag || 'PREMIUM')}&lt;/code&gt;&#10; &lt;b&gt;Bitiş Tarihi:&lt;/b&gt; &lt;code&gt;${expireDate.toLocaleDateString('tr-TR', { day: 'numeric', month: 'long', year: 'numeric' })}&lt;/code&gt;&#10; &lt;b&gt;Kota:&lt;/b&gt; &lt;code&gt;${trafficLeftGB} GB / ${trafficLimitGB} GB&lt;/code&gt;&#10;&#10;&lt;b&gt;Durum:&lt;/b&gt; ${statusText}&#10;&#10;&lt;b&gt;Happ CryptoLink:&lt;/b&gt;&#10;&lt;pre&gt;&lt;code&gt;${escapeHTML(user.happ.cryptoLink)}&lt;/code&gt;&lt;/pre&gt;&#10;&#10;Uygulamanız yoksa aşağıdan indirebilirsiniz &#10;    `;&#10;&#10;    await ctx.reply(accountInfo, { &#10;      parse_mode: &quot;HTML&quot;,&#10;      reply_markup: appDownloadKeyboard &#10;    });&#10;&#10;  } catch (error: any) {&#10;    await ctx.answerCallbackQuery(&quot;Hata!&quot;);&#10;    await ctx.reply(`Hesap bilgileriniz alınırken bir hata oluştu: ${error.message}`);&#10;  }&#10;});&#10;&#10;// &quot;Try for Free&quot; mantığını yeniden kullanılabilir bir fonksiyona taşıyalım&#10;async function handleTryFree(ctx: Context) {&#10;  const telegramId = ctx.from?.id;&#10;  const username = ctx.from?.username;&#10;&#10;  if (!telegramId) {&#10;    await ctx.answerCallbackQuery?.(&quot;Hata!&quot;);&#10;    await ctx.reply(&quot;Telegram ID'niz alınamadı. Lütfen tekrar deneyin.&quot;);&#10;    return;&#10;  }&#10;&#10;  if (!username) {&#10;    await ctx.answerCallbackQuery?.();&#10;    await ctx.reply(&quot;Kayıt olabilmek için bir Telegram kullanıcı adınızın olması gerekmektedir.&quot;);&#10;    return;&#10;  }&#10;&#10;  try {&#10;    // Kullanıcının zaten var olup olmadığını Telegram ID ile kontrol et&#10;    const existingUser = await getUserByTelegramId(telegramId);&#10;    if (existingUser) {&#10;      await ctx.answerCallbackQuery?.();&#10;      await ctx.reply(`Bu Telegram hesabı ile zaten bir kullanıcı mevcut: &lt;code&gt;${existingUser.username}&lt;/code&gt;\n\nHesap durumunuzu kontrol etmek için ana menüdeki &quot;Hesap Durumu&quot; düğmesini kullanabilirsiniz.`, { parse_mode: &quot;HTML&quot; });&#10;      return;&#10;    }&#10;&#10;    await ctx.answerCallbackQuery?.(&quot;Deneme hesabınız oluşturuluyor...&quot;);&#10;&#10;    // Kullanıcı adı çakışmalarını önlemek için benzersiz bir username üret&#10;    let finalUsername = username;&#10;    try {&#10;      const existingByUsername = await getUserByUsername(username);&#10;      if (existingByUsername) {&#10;        const base = username.slice(0, Math.max(0, 30));&#10;        const suffix = `-${Math.floor(1000 + Math.random() * 9000)}`;&#10;        finalUsername = `${base}${suffix}`;&#10;      }&#10;    } catch (e) {&#10;      // username kontrolü başarısızsa sessizce devam et, API zaten doğrulayacaktır&#10;    }&#10;&#10;    const squadUuid = process.env.INTERNAL_SQUAD_UUID;&#10;&#10;    if (!squadUuid) {&#10;      throw new Error(&quot;INTERNAL_SQUAD_UUID environment variable is not set&quot;);&#10;    }&#10;&#10;    // 3 gün sonrası için son kullanma tarihi oluştur&#10;    const expireAt = new Date();&#10;    expireAt.setDate(expireAt.getDate() + 3);&#10;&#10;    const newUser = {&#10;      username: finalUsername,&#10;      telegramId,&#10;      tag: &quot;TRIAL&quot;, // Kullanıcıya TRIAL etiketini ekle&#10;      expireAt: expireAt.toISOString(),&#10;      trafficLimitBytes: 2 * 1024 * 1024 * 1024, // 2 GB&#10;      trafficLimitStrategy: &quot;NO_RESET&quot;,&#10;      activeInternalSquads: [squadUuid],&#10;    };&#10;&#10;    // Username çakışmalarına karşı birkaç kez dene&#10;    let createdUser: any = null;&#10;    const baseName = finalUsername.slice(0, Math.max(0, 30));&#10;    for (let attempt = 0; attempt &lt; 5; attempt++) {&#10;      try {&#10;        createdUser = await createUser(newUser);&#10;        break;&#10;      } catch (err: any) {&#10;        const msg = String(err?.message || &quot;&quot;);&#10;        const looksLikeUsernameConflict = msg.includes(&quot;A018&quot;) || msg.includes(&quot;409&quot;) || msg.toLowerCase().includes(&quot;username&quot;);&#10;        if (!looksLikeUsernameConflict || attempt === 4) {&#10;          throw err;&#10;        }&#10;        const suffix = `-${Math.floor(1000 + Math.random() * 9000)}`;&#10;        finalUsername = `${baseName}${suffix}`;&#10;        newUser.username = finalUsername;&#10;      }&#10;    }&#10;&#10;    const myAccountKeyboard = new InlineKeyboard().text(&quot; Hesabım&quot;, &quot;my_account&quot;);&#10;&#10;    await ctx.reply(` Deneme hesabınız başarıyla oluşturuldu, @${username}!\n\nHesabınız &lt;b&gt;3 gün&lt;/b&gt; geçerlidir ve &lt;b&gt;2 GB&lt;/b&gt; trafik limitiniz bulunmaktadır.\n\nAşağıdaki butona tıklayarak hesap detaylarınızı görebilirsiniz.`, {&#10;      parse_mode: &quot;HTML&quot;,&#10;      reply_markup: myAccountKeyboard,&#10;    });&#10;  } catch (error: any) {&#10;    const telegramIdForCatch = ctx.from?.id;&#10;    const msg = String(error?.message || &quot;&quot;);&#10;    // A018 genellikle sunucuda mevcut hesap/benzersizlik ihlali durumunu ifade eder&#10;    if (msg.includes(&quot;A018&quot;) &amp;&amp; telegramIdForCatch) {&#10;      try {&#10;        const existing = await getUserByTelegramId(telegramIdForCatch);&#10;        if (existing) {&#10;          const myAccountKeyboard = new InlineKeyboard().text(&quot; Hesabım&quot;, &quot;my_account&quot;);&#10;          await ctx.answerCallbackQuery?.();&#10;          await ctx.reply(&quot;Bu Telegram hesabıyla zaten bir kullanıcı mevcut. Hesap detaylarını görüntülemek için aşağıdaki düğmeyi kullanın.&quot;, { reply_markup: myAccountKeyboard });&#10;          return;&#10;        }&#10;      } catch {}&#10;    }&#10;    await ctx.answerCallbackQuery?.(&quot;Hata!&quot;);&#10;    await ctx.reply(`Kullanıcı oluşturulurken bir hata oluştu: ${error.message}`);&#10;  }&#10;}&#10;&#10;// Internal test endpoint: webhook'u manuel test etmek için (PROD: koruma gerektirir)&#10;app.post('/internal/test-webhook/:telegramId', async (req: Request, res: Response) =&gt; {&#10;  const token = req.headers['x-internal-token'] as string | undefined;&#10;  const expected = process.env.INTERNAL_NOTIFY_TOKEN;&#10;  if (!expected || token !== expected) {&#10;    return res.status(403).json({ error: 'Forbidden' });&#10;  }&#10;&#10;  const telegramIdParam = req.params.telegramId;&#10;  const reason = req.body?.reason as string | undefined;&#10;&#10;  try {&#10;    const user = await getUserByTelegramId(Number(telegramIdParam));&#10;    if (!user) {&#10;      return res.status(404).json({ error: 'User not found' });&#10;    }&#10;&#10;    // Webhook event simülasyonu&#10;    const mockEvent = {&#10;      event: 'user.limited',&#10;      timestamp: new Date().toISOString(),&#10;      data: { user }&#10;    };&#10;&#10;    const { handleWebhook } = await import('./webhook');&#10;    const result = await handleWebhook(bot, mockEvent, reason);&#10;    res.json(result);&#10;  } catch (e: any) {&#10;    console.error('Internal test error:', e);&#10;    res.status(500).json({ error: String(e?.message || e) });&#10;  }&#10;});&#10;&#10;// Webhook endpoint: RemnaWave panelinden gelen olayları dinle&#10;app.post('/endpoint', async (req: Request, res: Response) =&gt; {&#10;  try {&#10;    const signature = req.headers['x-webhook-signature'] as string | undefined;&#10;    const webhookSecret = process.env.WEBHOOK_SECRET;&#10;&#10;    // Webhook secret varsa imza doğrula&#10;    if (webhookSecret &amp;&amp; signature) {&#10;      const { verifyWebhookSignature } = await import('./webhook');&#10;      const payload = JSON.stringify(req.body);&#10;      const isValid = verifyWebhookSignature(payload, signature, webhookSecret);&#10;&#10;      if (!isValid) {&#10;        console.warn('Invalid webhook signature');&#10;        return res.status(401).json({ error: 'Invalid signature' });&#10;      }&#10;    }&#10;&#10;    const event = req.body;&#10;    console.log('Webhook event received:', event.event);&#10;&#10;    const { handleWebhook } = await import('./webhook');&#10;    const result = await handleWebhook(bot, event);&#10;&#10;    res.json({ received: true, result });&#10;  } catch (e: any) {&#10;    console.error('Webhook error:', e?.message || e);&#10;    res.status(500).json({ error: 'Internal server error' });&#10;  }&#10;});&#10;&#10;// ...existing code...&#10;&#10;async function startApp() {&#10;  // Start the Express server&#10;  app.listen(port, () =&gt; {&#10;    console.log(`API server listening on port ${port}`);&#10;    console.log(`Webhook endpoint: POST /endpoint`);&#10;  });&#10;&#10;  // Start the Telegram bot&#10;  await validateConfigAtStartup();&#10;  bot.start();&#10;  console.log(&quot;Bot started!&quot;);&#10;  console.log(&quot;Webhook mode: Real-time notifications enabled ⚡&quot;);&#10;}&#10;&#10;startApp();&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/src/webhook.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/src/webhook.ts" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="import &quot;dotenv/config&quot;;&#10;import { Bot } from &quot;grammy&quot;;&#10;&#10;// Webhook ile gelen olayları işleyen modül&#10;// RemnaWave Webhook Documentation: https://docs.rw/docs/features/webhooks&#10;&#10;// Bildirim gönderilen kullanıcıları takip et (sadece bir kez gönder)&#10;const notifiedUsers: Record&lt;string, boolean&gt; = {};&#10;&#10;export interface WebhookEvent {&#10;  event: string;&#10;  timestamp: string;&#10;  data: {&#10;    user?: {&#10;      uuid: string;&#10;      username: string;&#10;      status: string;&#10;      telegramId?: number;&#10;      usedTrafficBytes?: number;&#10;      trafficLimitBytes?: number;&#10;      expireAt?: string;&#10;    };&#10;  };&#10;}&#10;&#10;export async function handleWebhook(bot: Bot&lt;any&gt;, event: WebhookEvent, reasonOverride?: string) {&#10;  try {&#10;    const { event: eventType, data } = event;&#10;    const user = data?.user;&#10;&#10;    if (!user) {&#10;      console.warn('Webhook event received without user data:', eventType);&#10;      return { ok: false, reason: 'no_user_data' };&#10;    }&#10;&#10;    const userUuid = user.uuid;&#10;    const telegramId = user.telegramId;&#10;&#10;    if (!telegramId) {&#10;      console.log(`User ${user.username} has no telegramId, skipping notification`);&#10;      return { ok: false, reason: 'no_telegram_id' };&#10;    }&#10;&#10;    // Sadece status değişikliği veya kullanım olaylarında bildirim gönder&#10;    const shouldNotify =&#10;      eventType === 'user.status.changed' ||&#10;      eventType === 'user.disabled' ||&#10;      eventType === 'user.limited' ||&#10;      eventType === 'user.expired';&#10;&#10;    if (!shouldNotify) {&#10;      return { ok: false, reason: 'event_not_relevant' };&#10;    }&#10;&#10;    // Kullanıcı kısıtlı mı?&#10;    const isRestricted =&#10;      user.status === 'LIMITED' ||&#10;      user.status === 'EXPIRED' ||&#10;      user.status === 'DISABLED';&#10;&#10;    if (!isRestricted) {&#10;      return { ok: false, reason: 'user_not_restricted' };&#10;    }&#10;&#10;    // Daha önce bildirim gönderildiyse atla&#10;    if (notifiedUsers[userUuid]) {&#10;      console.log(`User ${user.username} already notified, skipping`);&#10;      return { ok: false, reason: 'already_notified' };&#10;    }&#10;&#10;    // Bildirim mesajını hazırla&#10;    const reason = &#10;      reasonOverride ||&#10;      (user.status === 'LIMITED' &#10;        ? 'Trafik kotanız doldu.' &#10;        : user.status === 'EXPIRED' &#10;        ? 'Abonelik süreniz sona erdi.' &#10;        : 'Hesabınız devre dışı bırakıldı.');&#10;&#10;    const text = `⚠️ Hesabınız kısıtlandı!\n\n${reason}\n\nHesap detaylarınızı görmek için aşağıdaki butona tıklayın.`;&#10;&#10;    // Telegram bildirimi gönder&#10;    await bot.api.sendMessage(telegramId, text, {&#10;      reply_markup: {&#10;        inline_keyboard: [&#10;          [{ text: ' Hesap Bilgilerim', callback_data: 'my_account' }]&#10;        ]&#10;      }&#10;    });&#10;&#10;    // Başarılı, kullanıcıyı işaretle&#10;    notifiedUsers[userUuid] = true;&#10;    console.log(`✅ Notification sent to user ${user.username} (${telegramId})`);&#10;&#10;    return { ok: true, event: eventType };&#10;  } catch (e: any) {&#10;    console.error('Webhook handler error:', e?.message || e);&#10;    return { ok: false, error: e?.message || e };&#10;  }&#10;}&#10;&#10;// Webhook imzasını doğrula (güvenlik için)&#10;export function verifyWebhookSignature(payload: string, signature: string, secret: string): boolean {&#10;  const crypto = require('crypto');&#10;  const hmac = crypto.createHmac('sha256', secret);&#10;  hmac.update(payload);&#10;  const expectedSignature = hmac.digest('hex');&#10;  return signature === expectedSignature;&#10;}&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>